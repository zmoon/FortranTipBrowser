# This data is used to generate the tip pages

tips:

  # 17-Dec-2021

  - title: Hello World
    intro: |
      [Hello World](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program) in Fortran is
    file: hello-world.f90
    concl: |
      (Every Fortran program must have an `end` statement.)
    url: https://twitter.com/fortrantip/status/1471887565745799173
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Hello World in Fortran is<br><br>print*,&quot;Hello, World.&quot;<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471887565745799173?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Intrinsic data types
    intro: |
      Fortran has 5 intrinsic data types: integer, real, complex, logical, and character.
      The types have various `kind`s that determine the range of data they can represent.
    file: ~
    url: https://twitter.com/fortrantip/status/1471890355561943054
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran has 5 intrinsic data types: integer, real, complex, logical, and character. The types have various KINDs that determine the range of data they can represent.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471890355561943054?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`do` loop'
    intro: |
      The primary looping construct in Fortran is `do` ... `end do`.
      A program to print the sum the squares of the integers from 1 to 5 is
    file: do-enddo.f90
    url: https://twitter.com/fortrantip/status/1471891644370796550
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The primary looping construct in Fortran is do ... end do. A program to print the sum the squares of the integers from 1 to 5 is<br><br>implicit none<br>integer :: i,ssq<br>ssq = 0<br>do i=1,5<br> ssq = ssq + i**2<br>end do<br>print*,&quot;sum of squares is &quot;,ssq<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471891644370796550?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`exit`ing a `do` loop'
    intro: |
      You `exit` a loop as shown in the code below,
      which accumulates the sums of squared integers until the sum exceeds 100.
    file: do-exit.f90
    url: https://twitter.com/fortrantip/status/1471895490346291206
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">You EXIT a loop as shown in the code below, which accumulates the sums of squared integers until the sum exceeds 100<br><br>implicit none<br>integer :: i,ssq<br>ssq = 0<br>i = 0<br>do<br> i = i+1<br> ssq = ssq + i**2<br> if (ssq &gt; 100) exit<br>end do <br>print*,&quot;sum of squares from 1 to &quot;,i,&quot; is&quot;,ssq<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471895490346291206?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Fortran compilers and tutorials
    intro: |
      Two good sites to get started with Fortran are
      <https://fortran-lang.org> and <https://fortranwiki.org/fortran/show/HomePage>.
      A good free compiler is `gfortran`, part of GCC.
      Intel Fortran is also free.
      LFortran is an interactive compiler that covers most but not yet all of Fortran.
    file: ~
    url: https://twitter.com/fortrantip/status/1471897319671046147
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Two good sites to get started with Fortran are <a href="https://t.co/i6lkcIfPqy">https://t.co/i6lkcIfPqy</a> and <a href="https://t.co/uxmVspKsPm">https://t.co/uxmVspKsPm</a> . A good free compiler is gfortran, part of gcc. Intel Fortran is also free. LFortran is an interactive compiler that covers most but not yet all of Fortran.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471897319671046147?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`**` is the exponentiation operator'
    intro: |
      The exponentiation operator in Fortran is `**`, as in Python.
    file: expon.f90
    concl: |
      Many Fortran operators and intrinsic functions are elemental, and brackets denote arrays.
    url: https://twitter.com/fortrantip/status/1471903802185986050
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The exponentiation operator in Fortran is **, as in Python. <br><br>print*,1.2**2<br><br>gives 1.44<br><br>Many Fortran operators and intrinsic functions are elemental, and brackets denote arrays, so<br><br>print*,[1.0,1.1,1.2,1.3]**2<br><br>gives<br><br>1.00000000 1.21000004 1.44000006 1.68999982</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471903802185986050?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Integer division truncates
    intro: ~
    file: int-trunc.f90
    concl: |
      2/3 = 0 in Fortran because the quotient of two integers is truncated to an integer.
      The quotient of an integer and a real is a real.
    url: https://twitter.com/fortrantip/status/1471936756857643008
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">print*,2+3,2-3,2*3,2/3,2/3.0,2.0/3,2**3<br><br>gives<br><br>5 -1 6 0 0.6666667 0.6666667 8<br><br>2/3 = 0 in Fortran because the quotient of two integers is truncated to an integer. The quotient of an integer and a real is a real.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471936756857643008?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Array intrinsic functions: `sum`, `minval`, `maxval`, `minloc`, `findloc`'
    intro: |
      Fortran has many array intrinsic functions. Below, `!` starts a comment.
    file: array-intrinsics.f90
    url: https://twitter.com/fortrantip/status/1471989760046641153
    embed: '<blockquote class="twitter-tweet"><p lang="fr" dir="ltr">Fortran has many array intrinsic functions. Below, ! starts a comment.<br><br>integer, parameter :: vec(3) = [4,1,9]<br>print*,minval(vec),maxval(vec) ! output: 1 9<br>print*,sum(vec),product(vec) ! 14 36<br>print*,minloc(vec),maxloc(vec) ! 2 3<br>print*,findloc(vec,9),findloc(vec,8) ! 3 0<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471989760046641153?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Fortran array sections contain both endpoints
    intro: |
      Fortran array sections contain both endpoints like Julia, Matlab and R, unlike Python.
    file: array-sections.f90
    url: https://twitter.com/fortrantip/status/1471994100161388545
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran array sections contain both endpoints like Julia, Matlab and R, unlike Python.<br><br>integer, parameter :: v(3) = [10,20,30]<br>print*,v(1:2) ! output 10 20<br>print*,v(:2) ! 10 20<br>print*,v(2:3) ! 20 30<br>print*,v(2:) ! 20 30<br>print*,v(::2) ! 10 30 -- stride of 2</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471994100161388545?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Fortran arrays can have any lower bound (the default is 1)
    intro: |
      Fortran arrays can have any lower bound. 
      The default is 1.
      Array functions have optional mask arguments to determine the elements used.    
    file: array-lbound.f90
    url: https://twitter.com/fortrantip/status/1471997763848183810
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran arrays can have any lower bound. <br>The default is 1. Array functions have optional mask arguments to determine the elements used.<br><br>integer :: v(-1:1) = [1,-2,3]<br>print*,lbound(v),ubound(v),size(v) ! -1 1 3<br>print*,sum(v) ! 2<br>print*,sum(v,mask=v&gt;0) ! 4 -- sum excludes -2<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471997763848183810?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`sum` and other array functions have an optional `dim`ension argument'
    intro: ~
    file: sum-dim.f90
    url: https://twitter.com/fortrantip/status/1472018791525720069
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">sum and other array functions have an optional dim(ension) argument<br><br>integer :: v(2,3) ! 2x3 matrix<br>v(1,:) = [1,2,3]<br>v(2,:) = 10*v(1,:) ! set to [10,20,30]<br>print*,sum(v) ! all elements: 66<br>print*,sum(v,dim=1) ! sum each row: 6 60<br>print*,sum(v,dim=2) ! sum each col: 11 22 33</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472018791525720069?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-Dec-2021

  - title: Fortran has allocation-on-assignment
    intro: |
      Fortran has allocation on assignment,
      but you cannot use the `allocate` statement for an array that is already allocated.
    file: alloc-on-assign.f90
    url: https://twitter.com/fortrantip/status/1472181598833549316
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran has allocation on assignment, but you cannot use the ALLOCATE statement for an array that is allocated<br><br>integer, allocatable :: v(:)<br>v = [4,9]<br>deallocate(v) ! necessary for line below to work<br>allocate (v,source=[4,9]) ! same as above</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472181598833549316?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'
    
  - title: 'New Fortran code should use free source form and `.f90` suffix'
    intro: |
      New Fortran code should be written using free source form and stored in a file with a `.f90` file extension.
      Free form was introduced in the Fortran 90 standard,
      but using the `.f90` suffix does NOT mean the code is restricted to Fortran 90 features.
      Don't use the `.f95`, `.f08`, `.f18` suffixes, which are not recognized by many tools.
    file: ~
    url: https://twitter.com/fortrantip/status/1472183935044145157
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">New Fortran code should be written using free source form and stored in a file with the .f90 suffix. Free form was introduced in the Fortran 90 standard, but using the .f90 suffix does NOT mean the code is restricted to Fortran 90 features. Don&#39;t use .f95 .f08 .f18 suffixes.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472183935044145157?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`if`-`else if`-`end if` block'
    intro: ~
    file: if-block.f90
    url: https://twitter.com/fortrantip/status/1472202678054920196
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If-elseif-endif block:<br><br>integer :: i<br>do i=-1,1<br> print*,i<br> if (i &lt; 0) then<br> print*,&quot;negative&quot;<br> else if (i == 0) then<br> print*,&quot;zero&quot;<br> else<br> print*,&quot;positive&quot;<br> end if<br>end do<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472202678054920196?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`merge(x, y, cond)`'
    intro: |
      `merge(x, y, cond)` returns `x` if the condition `cond` is true, otherwise `y`.
      We can get the same result as the previous tip:
    file: merge.f90
    concl: |
      Similar to the three-argument usage of
      [`numpy.where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html).
    url: https://twitter.com/fortrantip/status/1472205323763073026
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">merge(x,y,condition) returns x if condition is true, otherwise y. Same output as previous:<br><br>integer :: i<br>do i=-1,1<br> print*,i<br> ! &quot;zero&quot; padded to have same length as &quot;negative&quot;<br> print*,merge(&quot;negative&quot;,merge(&quot;zero &quot;, &amp; <br> &quot;positive&quot;,i==0),i&lt;0)<br>end do<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472205323763073026?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'An array of character variables has elements of the same `len`gth'
    intro: ~
    file: char-array.f90
    url: https://twitter.com/fortrantip/status/1472207576133783564
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An array of character variables has elements of the same LEN(gth).<br><br>character(len=5) :: w(3)<br>w = [&quot;one&quot;,&quot;four&quot;,&quot;seven&quot;] ! invalid<br>w = [&quot;one &quot;,&quot;four &quot;,&quot;seven&quot;] ! same as below<br>w = [character(5) :: &quot;one&quot;,&quot;four&quot;,&quot;seven&quot;] <br>print*,w<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472207576133783564?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Character variables are padded with spaces at the end if necessary
    intro: |
      Fortran character variables are padded with spaces at the end if necessary.
      The `//` operator concatenates.
      `trim` removes trailing spaces.[^1]

      [^1]: Use `trim(adjustl(s))` to remove both leading and trailing spaces.
    file: char-pad.f90
    url: https://twitter.com/fortrantip/status/1472209602074849285
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran character variables are padded with spaces at the end if necessary. The // operator concatenates. Trim removes trailing spaces.<br><br>character (len=5) :: v = &quot;one&quot;<br>print*,&quot;&#39;&quot; // v // &quot;&#39;&quot; ! &#39;one &#39;<br>print*,&quot;&#39;&quot; // trim(v) // &quot;&#39;&quot; ! &#39;one&#39;<br>print*,len(v),len_trim(v) ! 5 3<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472209602074849285?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Fortran has a one-line `if`'
    intro: |
      In addition to `if`-`else if`, Fortran has a one-line `if`:

      ```text
      if (condition) executable_statement
      ```
    file: if-one-line.f90
    url: https://twitter.com/fortrantip/status/1472365082067755017
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In addition to if-elseif, Fortran has a one-line if:<br>if (condition) executable_statement<br><br>integer :: i<br>do i=-1,1<br> if (i /= 0) print*,i,1/i ! one-line if equivalent to below<br> if (i /= 0) then<br> print*,i,1/i<br> end if<br>end do<br>end<br>! output:<br>! -1 -1<br>! -1 -1<br>! 1 1<br>! 1 1</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472365082067755017?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-Dec-2021 (first day that stored some source files in the Beliavsky/FortranTip repo)

  - title: '`associate` creates an alias for expressions or variables'
    intro: ~
    file: assoc.f90
    url: https://twitter.com/fortrantip/status/1472565511628197891
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Associate creates an alias for expressions or variables.<br><br>integer, allocatable :: u(:)<br>u = [4,9]<br>associate (v =&gt; u)<br>v = v - 2<br>print*,v ! 2 7<br>print*,u ! 2 7<br>associate (w =&gt; [4,9])<br>print*,w<br>w = w - 2 ! illegal since w set to a constant expression<br>end associate<br>end associate<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472565511628197891?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Loop variable after completion
    intro: |
      The loop variable equals the upper bound plus the stride
      after normal completion of a loop.
    file: loop-var.f90
    url: https://twitter.com/fortrantip/status/1472598697489965061
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The loop variable equals the upper bound plus the stride<br>after normal completion of a loop<br><br>integer :: i<br>do i=1,3<br> if (i &gt; 1) exit<br>end do<br>print*,i ! 2<br>do i=1,3 ! stride of 1<br> continue ! placeholder<br>end do<br>print*,i ! 4<br>do i=1,3,2 ! stride of 2<br> continue<br>end do<br>print*,i ! 5<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472598697489965061?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>' 

  - title: '`pack` selects elements'
    intro: ~
    file: pack.f90
    url: https://twitter.com/fortrantip/status/1472600871192125451
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Pack selects elements<br><br>integer :: v(3) = [1,-4,9]<br>print*,pack(v,v&gt;0) ! 1 9 -- keep values &gt; 0<br>print*,count(v&gt;0) ! 2 -- count values &gt; 0<br>print*,size(v) ! 3<br>print*,sum(v) ! 6<br>print*,sum(v,v&gt;0) ! 10 -- sum has optional mask<br>print*,sum(pack(v,v&gt;0)) ! 10<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472600871192125451?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Functions should be `pure` and have `intent(in)` arguments
    intro: |
      `intent(in)` arguments cannot be changed.
      `pure` = no side effects.
      Use `subroutine` instead for a procedure with side effects.
    file: func.f90
    concl: |
      `real` in the function definition line indicates the type of the return value.
      By default, the value corresponding to a variable with the same name as the function
      is returned (here `area`).
    url: https://twitter.com/fortrantip/status/1472603894886932482
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Demo of a Fortran function. Intent(in) arguments<br>cannot be changed. Function arguments should be intent(in). Pure = no side-effects.<br><br>print*,area(3.,4.) ! 12<br>contains<br>real pure function area(length,width)<br>real, intent(in) :: length,width<br>area = length*width<br>end function area<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472603894886932482?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`elemental` functions broadcast arguments'
    intro: ~
    file: elemental.f90
    url: https://twitter.com/fortrantip/status/1472606914857078793
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Elemental functions broadcast arguments. Neat Fortran feature!<br><br>print*,area(3,4) ! 12<br>print*,area(3,[4,5]) ! 12 15<br>print*,area([3,4],[4,5]) ! 12 20<br>contains<br>integer elemental function area(length,width)<br>integer, intent(in) :: length,width<br>area = length*width<br>end function area<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472606914857078793?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Put functions and subroutines in modules to ensure that interfaces are checked
    intro: |
      Fortran procedures should be defined in modules to
      ensure that interfaces are checked.
    file: mod.f90
    url: https://twitter.com/fortrantip/status/1472610403884670976
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran procedures should be defined in modules to<br>ensure that interfaces are checked.<br><br>module m<br>contains<br>integer function area(length,width)<br>integer, intent(in) :: length,width<br>area = length*width<br>end<br>end module m<br>program main<br>use m<br>print*,area(3,4) ! 12<br>end program main</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472610403884670976?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Avoid polluting the namespace by using `use`-`only`'
    intro: |
      In Fortran, 
      ```fortran
      use m
      ```
      is equivalent to Python
      ```python
      from m import *
      ```
      It is better to write
      ```fortran
      use m, only: foo, bar
      ```
      to avoid polluting the namespace and to clarify the origin of imported entities.
    file: ~
    url: https://twitter.com/fortrantip/status/1472613921886552065
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In Fortran, <br><br>use m<br><br>is equivalent to Python<br><br>from m import *<br><br>It is better to write <br><br>use m, only: foo, bar<br><br>to avoid polluting the namespace and to clarify the origin of imported entities.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472613921886552065?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # This is the first one with source code file in the FortranTip repo
  - title: Function overloading using an interface with module procedures
    intro: ~
    file: interface.f90
    file0: same
    url: https://twitter.com/fortrantip/status/1472629090758836229
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/qsfPFLVUkl">pic.twitter.com/qsfPFLVUkl</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472629090758836229?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO: maybe split into two?
  - title: Optional arguments (and the `random_number` intrinsic)
    intro: ~
    file: optional.f90
    file0: same
    concl: |
      ```{important}
      Within a procedure, you should test that an optional argument is present
      (with the `present` intrinsic function) before attempting to use it.
      Using an optional argument that is not present is a common cause of program crashes.
      ```
    url: https://twitter.com/fortrantip/status/1472684194765672450
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/ZNqwgg3Wgq">pic.twitter.com/ZNqwgg3Wgq</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472684194765672450?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Define and call a subroutine
    intro: ~
    file: subroutine.f90
    file0: subroutine.f90
    concl: |
      Subroutines are commonly used to return multiple values,
      although a function can return an array or a user-defined type that contains multiple values.
      Use functions when possible, but subroutines are often needed.
      The subroutine is invoked with the `call` statement.
    url: https://twitter.com/fortrantip/status/1472692305522044932
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/Wi7Imqi5vW">pic.twitter.com/Wi7Imqi5vW</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472692305522044932?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Subroutines can have `intent(in out)` arguments, but functions should not'
    intro: |
      A procedure argument can be `intent(in out)`,
      which means that it is an input that can be overwritten.
      Functions should not have such arguments, but subroutines often do.
      `intent(out)` means the argument is set to uninitialized upon entering the procedure.
    file: intent-in-out.f90
    file0: intent_in_out.f90
    url: https://twitter.com/fortrantip/status/1472696912541364224
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/3FjJkJUHSn">pic.twitter.com/3FjJkJUHSn</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472696912541364224?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Specify function and subroutine `intent`s'
    intro: |
      Function and subroutine argument `intent`s were introduced in the Fortran 90 standard.
      Much Fortran code does not specify intents, which is legal, but all new code should.
      Arguments should be `intent(in)` or `intent(out)` unless `intent(in out)` is necessary.
    file: ~
    url: https://twitter.com/fortrantip/status/1472698233298333699
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Function and subroutine argument INTENTs were introduced in the Fortran 90 standard. Much Fortran code does not specify intents, which is legal, but all new code should. Arguments should be intent(in) or intent(out) unless intent(in out) is necessary.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472698233298333699?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Procedures can be recursive
    intro: |
      Fortran procedures declared `recursive` can call themselves.
    file: recursive.f90
    file0: recursive.f90
    concl: |
      ````{warning}

      In GFortran v9 and v10 (and lower versions, presumably),
      this isn't allowed, and we get:
      ```text
      Error: ELEMENTAL attribute conflicts with RECURSIVE attribute
      ```
      ````
    url: https://twitter.com/fortrantip/status/1472702427740745728
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/czICWzekYU">pic.twitter.com/czICWzekYU</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472702427740745728?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Use `parameter`s in modules to define constants
    intro: |
      A physical or mathematical constant such as $\pi$ that will be used 
      in many parts of a program should be defined as a `parameter` in a 
      module that is `use`d where needed.
      In the code below, `pi` is used both in module `m` and the main program.
    file: module-parameter.f90
    file0: module_parameter.f90
    concl: |
      One should declare a module `private` and list as `public`
      the entities that will be referenced outside the module.
      Module entities are public by default.
    url: https://twitter.com/fortrantip/status/1472718436040073226
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/vWJuAwle97">pic.twitter.com/vWJuAwle97</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472718436040073226?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Declare floating point variables with `kind`s'
    intro: |
      Although floating point variables can still be declared just `real`
      or `double precision` in Fortran, they should not be.
      Instead, the `kind` of `real` should be specified as a parameter
      that is used throughout the program.

      The code below can be changed from double to single or quadruple precision
      by simply changing the definition of `wp` (working precision) in `kind_mod`
      using the `kind` constants from the intrinsic `iso_fortran_env` module.

      Note the `_wp` suffix used in the literal constants for $\pi$ and $10.0$.
      Any literal constant without a suffix is considered single precision in Fortran,
      regardless of the number of digits provided.

      See <https://fortran-lang.org/learn/best_practices/floating_point> for more discussion.
    file: real-precision.f90
    file0: kind.f90
    url: https://twitter.com/fortrantip/status/1472771842242920451
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/Pxu7PbR5b6">pic.twitter.com/Pxu7PbR5b6</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472771842242920451?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # Note: this one is a comment on the previous tweet
  - title: 'Replace non-standard `REAL*8` declaration with `real(kind=real64)`'
    intro: |
      In older code, declarations such as[^1]
      ```fortran
      REAL*8 x
      ```
      are common but non-standard.
      They should be replaced by
      ```fortran
      real(kind=real64) :: x
      ```
      or 
      ```fortran
      real(kind=wp) :: x
      ```
      with `wp`[^wp] set appropriately (e.g., `use iso_fortran_env, only: wp => real64`).

      [^1]: Here indicating double precision (8-byte)
      [^wp]: "Working precision"
    file: ~
    url: https://twitter.com/fortrantip/status/1472772577600942083
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In older code, declarations such as<br><br>real*8 x<br><br>are common but non-standard. They should be replaced by<br><br>real(kind=real64) :: x<br><br>or <br><br>real(kind=wp) :: x<br><br>with wp set appropriately.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472772577600942083?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-Dec-2021

  - title: '`select case` for conditional execution'
    intro: |
      > A `select case` construct conditionally executes one block of
      > constructs or statements depending on the value of a scalar expression
      > in a select case statement.

      --- <https://riptutorial.com/fortran/example/5584/select-case-construct>

      `select case` is more restrictive and clear than an `if` block
      and should be used when it is possible, especially when there are many branches.
    file: select-case.f90
    file0: select_case.f90
    url: https://twitter.com/fortrantip/status/1472930444572336128
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/5R6yeSnvpY">pic.twitter.com/5R6yeSnvpY</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472930444572336128?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Reading user input
    intro: |
      The `read` statement is used to get data from the terminal or a file.
      To handle errors, set the `iostat` in the `read` call and check afterwards if it is zero.
      
      This program prompts the user for integers, one at a time, and prints their sum.
    file: read-sum.f90
    inputs: ["1", "1", "2", "3", "0"]
    file0: read_sum.f90
    url: https://twitter.com/fortrantip/status/1472941850218700805
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/pzKMXlNriJ">pic.twitter.com/pzKMXlNriJ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472941850218700805?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Using `read` and `write` for file I/O
    intro: |
      To `read` or `write` data from a file, it must first be connected to a unit.
      The `newunit` specifier, introduced in Fortran 2008, finds a free unit number.
      
      The program below writes some data to a file and then reads it back.
      When the number of records[^1] in a file is unknown, set and check the `iostat` of `read`,
      as shown[^2].

      [^1]: lines
      [^2]: and as in the previous tip
    file: write-read-file.f90
    concl: |
      ```{note}
      The initial (unset) value of `iunit` here is compiler-dependent,
      and the used `iunit` values created by using `newunit` are compiler- and situation-dependent.
      ```
    file0: read_write_file.f90
    url: https://twitter.com/fortrantip/status/1472999893631447043
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Using READ and WRITE for file i/o. <a href="https://t.co/Be3gH8SLnL">pic.twitter.com/Be3gH8SLnL</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472999893631447043?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 21-Dec-2021

  - title: Use unformatted stream of Fortran 2003 for large-scale I/O
    intro: |
      Consider using unformatted stream I/O introduced in Fortran 2003 for 
      large data sets. Formatted I/O converts numerical data to and from ASCII 
      and is much slower than unformatted.
      
      This program times the writing and reading of $10^6$ double precision floats[^size]
      using formatted and unformatted stream I/O.

      [^size]: float64; $10^6 \times 64\,\text{bits} = 8\,\text{MB}$
    file: stream-io.f90
    file0: stream_io.f90
    concl: |
      The degree of enhancement depends on $n$ and your hardware, but it should be considerable.

      ```{note}
      The Tweet, using $n=10^7$, reported that unformatted stream write and read were, respectively,
      25 and 260 times faster than formatted.
      ```

      ```{note}
      Using 64-bit integer arguments when calling `system_clock` allows for greater timing precision[^sys-clock].
      For 32-bit integers (default) or smaller, we only get millisecond precision, which was consistently
      not sufficient to measure the unformatted write time on my laptop.
      ```

      [^sys-clock]: <https://gcc.gnu.org/onlinedocs/gfortran/SYSTEM_005fCLOCK.html>
    url: https://twitter.com/fortrantip/status/1473261954244435973
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use unformatted stream of Fortran 2003 for large-scale I/O. <a href="https://t.co/I2PHa3YiaA">pic.twitter.com/I2PHa3YiaA</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1473261954244435973?ref_src=twsrc%5Etfw">December 21, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Name modules and the source files containing them consistently, with one module per file
    intro: |
      The convention @Beliavsky uses is that a module named `m_mod` is defined in a source file `m.f90`.
      That way if you see
      ```fortran
      use m_mod, only: foo
      ```
      in the code you know to look in `m.f90` for the definition of `foo`[^c].
      This also helps to avoid name clashes, since otherwise
      "it is quite frequent to have a procedure with the same name,
      or a type with the same name as the module"[^a][^b].

      This type of convention is not uncommon. For example:

      - Curcic's *Modern Fortran* ([code examples](https://github.com/modern-fortran)),
        where the modules are named `mod_<name>` and the files `mod_<name>.f90`

      - The [Community Land Model](https://github.com/ESCOMP/CTSM/tree/master/src),
        where *some* module names and their source file names are suffixed with `Mod`,
        or `Type` if the main purpose of the module is to define a single type

      - @everythingfunctional [recommends](https://everythingfunctional.gitlab.io/fortran-style-guide/)
        suffixing module names with `_m` (and types with `_t`) and naming the source file with 
        suffix `_m.f90`

      Additional recommendations:

      - > Prefix module names with the library name to avoid name clashes
        > when used as dependency in other projects

        --- <https://fortran-lang.org/learn/best_practices/modules_programs>

      ```{note}
      Similar to the `<name>_mod` module naming convention, since Fortran code is case-insensitive,
      a convention for naming types is to use `<name>_type`.
      ```

      [^a]: <https://everythingfunctional.gitlab.io/fortran-style-guide/>
      [^b]: <https://github.com/Fortran-FOSS-Programmers/Best_Practices#-entities-disambiguation>
      [^c]: Note that modern development environments, like [this VS Code extension](https://marketplace.visualstudio.com/items?itemName=hansec.fortran-ls)
        will generally provide go-to-definition functionality.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1473340740055015431
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Name modules and the source files containing them consistently, with one module per file. The convention I use is that a module named  m_mod is defined in a source file m.f90. That way if I see <br><br>use m_mod, only: foo<br><br>in my code I know to look in m.f90 for the definition of foo.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1473340740055015431?ref_src=twsrc%5Etfw">December 21, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 22-Dec-2021

  - title: If allocation errors must be handled, use `allocatable` rather than automatic arrays in procedures
    intro: |
      If allocation errors must be handled, use `allocatable` rather than automatic arrays in procedures,
      and check the `stat` of `allocate` in order to handle errors.
    file: alloc-stat.f90
    file0: automatic.f90
    concl: |
      From the Tweet, an example of handling this in a subroutine,
      considering the case of insufficient memory:
      ```fortran
      subroutine foo(x)
         implicit none

         real, intent(in) :: x(:)
         real :: y(size(x))
         ! ^ Automatic array -- program crashes if there is no memory for it
         real, allocatable :: z(:)
         integer :: ierr
   
         allocate (z(size(x)), stat=ierr)
         if (ierr /= 0) then  ! Handle allocation errors
            print *, "could not allocate z in foo"
            return
         end if

      end subroutine foo
      ```
    url: https://twitter.com/fortrantip/status/1473636468405030913
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If allocation errors must be handled, use ALLOCATABLE rather than automatic arrays in procedures, and check the STAT of ALLOCATE. <a href="https://t.co/EV4jE4pfdx">pic.twitter.com/EV4jE4pfdx</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1473636468405030913?ref_src=twsrc%5Etfw">December 22, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Use `g0.d` and `:` edit descriptors with infinite repeat count to write delimited (CSV, etc.) output'
    intro: |
      - `g0.d` will appropriately format any intrinsic type.
      - `:` causes processing to stop until the next I/O list item.
      - `*` repeats a format group as many times as necessary.
    file: csv.f90
    file0: ~
    concl: |
      ```{note}
      Intrinsic function `norm2` is part of the Fortran 2008 standard.
      ```
    url: https://twitter.com/fortrantip/status/1473680777279852553
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Combine the G0.d and colon edit descriptors, along with infinite repeat count, to write delimited (CSV, etc.) output. <a href="https://t.co/QfMmdEj7Fn">pic.twitter.com/QfMmdEj7Fn</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1473680777279852553?ref_src=twsrc%5Etfw">December 22, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Zero-size array constructor
    intro: |
      `[data_type ::]` is a zero-size array of type `data_type`.
      See examples below.
    file: zero-size.f90
    file0: zero_size.f90
    concl: |
      From the Tweet comments, one potential use for this is that
      "if a procedure has a required argument that is an integer array,
      you can pass `[integer ::]` from the caller."

      ```{note}
      The `associate` construct, used here,
      "yields simple abbreviations for more complex statements.
      It can be an alias for expressions or variables."[^a]
      ```

      [^a]: <https://fortranwiki.org/fortran/show/associate>
    url: https://twitter.com/fortrantip/status/1473848675566858242
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">[data_type :: ] is a zero-size array of type data_type.<a href="https://t.co/XmBx5W4ZBG">pic.twitter.com/XmBx5W4ZBG</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1473848675566858242?ref_src=twsrc%5Etfw">December 23, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 23-Dec-2021

  - title: Comparing Fortran and NumPy syntax
    intro: |
      Used to NumPy?
      Many of the Fortran intrinsics to deal with arrays will already be familiar to you.

      ```{list-table} A bit of Fortran vs NumPy
      ---
      header-rows: 1
      widths: 2 2 3
      ---
      * - Fortran
        - NumPy equivalent[^np]
        - Value

      * - ```fortran 
          integer :: a(2, 3)
          ```
        - ```python
          np.empty(
            (2, 3),
            dtype=np.int32
          )
          ```
        - Empty 2x3 array of int32 [^empty] [^order]

      * - ```fortran
          a = 1
          ```
        - ```python
          a[:] = 1
          ``` 
        - All array elements set to 1 [^np.full] [^setting]

      * - ```fortran
          size(a)
          ``` 
        - ```python
          a.size
          ``` 
        - 6

      * - ```fortran
          shape(a)
          ``` 
        - ```python
          a.shape
          ``` 
        - (2, 3) [^shape]

      * - ```fortran
          a(1,1) = 100
          ``` 
        - ```python
          a[0,0] = 100
          ``` 
        - Element in first row and first column set to 100

      * - ```fortran
          maxval(a)
          ``` 
        - ```python
          a.max()
          ``` 
        - 100

      * - ```fortran
          minval(a)
          ``` 
        - ```python
          a.min()
          ``` 
        - 1

      * - ```fortran
          sum(a)
          ``` 
        - ```python
          a.sum()
          ``` 
        - 105

      * - ```fortran
          sum(a, dim=1)
          ``` 
        - ```python
          a.sum(axis=0)
          ``` 
        - (101, 2, 2)
      ```

      [^np]: The NumPy examples assume
          ```python
          import numpy as np
          ```

      [^empty]: In Fortran, the "empty" array may get values set to zero,
          but this is not guaranteed (compiler and hardware(?) dependence).
          With NumPy, the unintialized array elements will not (all) be zero.

      [^np.full]: With NumPy,
          ```python
          a = np.full((m, n), value, dtype=np.int32)
          ```
          could be used  to achieve the result of the first two steps.

      [^order]: In Fortran, remember that the array elements are stored in
          column-major order.
          In NumPy, row-major order is the default, though you can specify
          [on creation](https://numpy.org/doc/stable/reference/generated/numpy.empty.html)
          or [transform to](https://numpy.org/doc/stable/reference/generated/numpy.asfortranarray.html)
          column-major order.

      [^setting]: **Notes**
          * Fortran supports the shorthand for setting all elements (`a = 1` above),
            but if you do that in Python, `a` becomes a single Python integer (`int`).
    
          * Fortran also supports setting all elements with colon syntax,
            but you must specify a `:` for each dimension.
    
          * In NumPy, `a[:]` and `a[...]` both work as shorthand for the entire array
            regardless of the number of dimensions,
            whereas in Fortran we need to give a colon for each dimension: `a(:,:)`.
    
          * For Fortran allocatable arrays, `a = ...` might[^b] re-allocate the array,
            whereas explicit `a(:,:) = ...` would not.
          
          [^b]: If it has already been allocated and the RHS is an array with
              a different shape from the LHS.
              `a = 1` like in our example still just sets all elements to 1.

      [^shape]: `shape(a)` (Fortran) returns an integer array,
          whereas `a.shape` (NumPy) returns a tuple of Python `int`s
          (i.e., not NumPy integers).


      ---
    file: cf-numpy.f90
    file0: ~
    concl: |
      ```{note}
      NumPy also provides a functional API that makes it look more like Fortran.
      See such comparisons and more here:
      <https://www.fortran90.org/src/rosetta.html>
      ```
    url: https://twitter.com/fortrantip/status/1473958733571104773
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Used to NumPy? Lots of the Fortran intrinsics to deal with arrays will already be familiar to you. <a href="https://t.co/GnKnbscsDX">pic.twitter.com/GnKnbscsDX</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1473958733571104773?ref_src=twsrc%5Etfw">December 23, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: List-directed vs. explicitly formatted output
    intro: |
      List-directed output (format `*`) is convenient,
      ```fortran
      ! Examples
      print *, x, y, z
      write (*, *) x, y, z
      write (unit_integer, *) x, y, z
      ```
      but don't use it when you care about layout as you'll lose control over
      spacing, line breaks and number of significant digits.
      If you care, use explicit formats instead.
    concl: |
      See Tip 041 for `g0.d` and `:` meaning in format syntax.
    file: list-directed.f90
    file0: ~
    url: https://twitter.com/fortrantip/status/1474105626611662857
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">List-directed output (format *) is convenient, but don&#39;t use it when you care about layout as you&#39;ll lose control over spacing, line breaks and number of significant digits. If you care, use explicit formats instead.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1474105626611662857?ref_src=twsrc%5Etfw">December 23, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Derived type definition, initialization, and operator overloading
    intro: |
      The following program demonstrates
      how to define a derived type, initialize it, access its components,
      convert it to a string, and define operators for it.

      The derived type here represents a specific month in time
      (i.e., year is also specified).
    concl: |
      ```{note}
      `idate` is getting highlighted in the module code above
      because it is shadowing the
      [intrinsic `idate` subroutine](https://gcc.gnu.org/onlinedocs/gfortran/IDATE.html),
      which we demonstrate at the end.
      ```

      Some further references:
      * <https://fortran-lang.org/learn/quickstart/derived_types.html>
      * <https://fortranwiki.org/fortran/show/Object-oriented+programming>
    file: ym-date-type.f90
    file0: date.f90
    url: https://twitter.com/fortrantip/status/1474169072665440259
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">How to define a derived type, initialize it, access its components, convert it to a string, and define operators for it. <a href="https://t.co/jcai3Usy25">pic.twitter.com/jcai3Usy25</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1474169072665440259?ref_src=twsrc%5Etfw">December 24, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'
    # TODO: current date thing should be separate tip?

  # 24-Dec-2021

  # TODO
  - title: Use GAMMA to compute factorials
    intro: |
      Why does Fortran not have a factorial function? It does, as for positive whole values of X the Gamma function simplifies to the factorial function for (X-1).
      That is,

      x! == gamma(x+1)

      Thanks to urbanjost for tip!
    file: ~
    file0: factorial.f90
    url: https://twitter.com/fortrantip/status/1474357943667671060
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Why does Fortran not have a factorial function? It does, as for positive whole values of X the Gamma function simplifies to the factorial function for (X-1).<br>That is,<br><br>x! == gamma(x+1)<br><br>Thanks to urbanjost for tip! <a href="https://t.co/fTAPvhKEpr">pic.twitter.com/fTAPvhKEpr</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1474357943667671060?ref_src=twsrc%5Etfw">December 24, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: RESHAPE with the optional ORDER and PAD arguments
    intro: |
      RESHAPE returns an array with a different shape than the SOURCE array. Optional ORDER argument changes the order of elements of SOURCE from the usual column major. Optional PAD argument fills the result, with recycling, after source is exhausted.
    file: ~
    file0: reshape_array.f90
    url: https://twitter.com/fortrantip/status/1474394605890244614
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">RESHAPE returns an array with a different shape than the SOURCE array. Optional ORDER argument changes the order of elements of SOURCE from the usual column major. Optional PAD argument fills the result, with recycling, after source is exhausted. <a href="https://t.co/Xb3RCZ6LcW">pic.twitter.com/Xb3RCZ6LcW</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1474394605890244614?ref_src=twsrc%5Etfw">December 24, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: CMPLX should be used with a KIND argument
    intro: |
      CMPLX(X,Y,[KIND]) returns a single precision complex variable, even if X and Y are double precision, unless a KIND is specified. 

      Merry Christmas and Happy Holidays! Posts may be sparse until the new year.
    file: ~
    file0: cmplx.f90
    url: https://twitter.com/fortrantip/status/1474537984066301959
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">CMPLX(X,Y,[KIND]) returns a single precision complex variable, even if X and Y are double precision, unless a KIND is specified. <br><br>Merry Christmas and Happy Holidays! Posts may be sparse until the new year. <a href="https://t.co/MD9tCw4pTB">pic.twitter.com/MD9tCw4pTB</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1474537984066301959?ref_src=twsrc%5Etfw">December 25, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 26-Dec-2021

  # TODO
  - title: Fortran is column-major
    intro: |
      The order you loop through multidimensional arrays can have a big impact on speed. Fortran is column-major, meaning consecutive elements of a column are stored next to each other in memory, and you should loop through arrays in this order.
    file: ~
    file0: column_major.f90
    url: https://twitter.com/fortrantip/status/1475049356155883524
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The order you loop through multidimensional arrays can have a big impact on speed. Fortran is column-major, meaning consecutive elements of a column are stored next to each other in memory, and you should loop through arrays in this order. <a href="https://t.co/oEtrOaMbzC">pic.twitter.com/oEtrOaMbzC</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475049356155883524?ref_src=twsrc%5Etfw">December 26, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Store data as an array of derived types or a derived type with array components?
    intro: |
      Whether to store data as an array of derived types or a derived type with array components also depends on how the data will typically be accessed.
    file: ~
    file0: derived_type_array.f90
    url: https://twitter.com/fortrantip/status/1475133178763427848
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Whether to store data as an array of derived types or a derived type with array components also depends on how the data will typically be accessed.<a href="https://t.co/UUqiYkaLO7">pic.twitter.com/UUqiYkaLO7</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475133178763427848?ref_src=twsrc%5Etfw">December 26, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 27-Dec-2021

  # TODO
  - title: Doubled delimiter in a string is regarded as a single character of the constant
    intro: |
      A doubled delimiter in a string without any embedded intervening blanks is regarded as a single character of the constant. One can also put a single quote in double quotes or a double quote in single quotes. Thanks to Amir Shahmoradi for tip.
    file: ~
    file0: doubled_delim.f90
    url: https://twitter.com/fortrantip/status/1475453317526528003
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A doubled delimiter in a string without any embedded intervening blanks is regarded as a single character of the constant. One can also put a single quote in double quotes or a double quote in single quotes. Thanks to Amir Shahmoradi for tip.<br> <a href="https://t.co/JSneWjHZgo">pic.twitter.com/JSneWjHZgo</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475453317526528003?ref_src=twsrc%5Etfw">December 27, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Intel Fortran Compiler (ifx)
    intro: |
      The Intel� Fortran Compiler (ifx), available in the oneAPI HPC Toolkit 2022.1, is production-ready for CPUs and GPUs. ifx is based on the Intel� Fortran Compiler Classic (ifort) frontend and runtime libraries, but uses LLVM backend compiler technology.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1475494838074318852
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The Intel� Fortran Compiler (ifx), available in the oneAPI HPC Toolkit 2022.1, is production-ready for CPUs and GPUs. ifx is based on the Intel� Fortran Compiler Classic (ifort) frontend and runtime libraries, but uses LLVM backend compiler technology.  <a href="https://t.co/YC72lJcOVC">https://t.co/YC72lJcOVC</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475494838074318852?ref_src=twsrc%5Etfw">December 27, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 28-Dec-2021

  # TODO
  - title: Use ALL(A==B) to test for array equality
    intro: |
      If size(A)==size(B), use ALL(A==B) to test for equality of arrays A and B and ANY(A==B) to test for equality of any corresponding elements.
    file: ~
    file0: all_any.f90
    url: https://twitter.com/fortrantip/status/1475822105358913540
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If size(A)==size(B), use ALL(A==B) to test for equality of arrays A and B and ANY(A==B) to test for equality of any corresponding elements. <a href="https://t.co/sx1gxm5XIh">pic.twitter.com/sx1gxm5XIh</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475822105358913540?ref_src=twsrc%5Etfw">December 28, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Consider using a tolerance to compare floats
    intro: |
      If the arrays are INTEGER or CHARACTER, then the comparison can be exact. For REAL or COMPLEX arrays, you should consider using a suitably small tolerance when comparing values. This and the previous tip are from urbanjost.
    file: ~
    file0: compare_floats.f90
    url: https://twitter.com/fortrantip/status/1475826650835214338
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If the arrays are INTEGER or CHARACTER, then the comparison can be exact. For REAL or COMPLEX arrays, you should consider using a suitably small tolerance when comparing values. This and the previous tip are from urbanjost. <a href="https://t.co/qjaMf5T06W">pic.twitter.com/qjaMf5T06W</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475826650835214338?ref_src=twsrc%5Etfw">December 28, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: ANY and ALL may not be the most efficient methods to compare arrays.
    intro: |
      ANY and ALL may not be the most efficient methods to compare arrays. They
      may generate a logical array the size of the input arrays or always test all elements, depending on how they are
      implemented. More from urbanjost:
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1475829444543717378
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">ANY and ALL may not be the most efficient methods to compare arrays. They<br>may generate a logical array the size of the input arrays or always test all elements, depending on how they are<br>implemented. More from urbanjost:<a href="https://t.co/8I5ed7nnDT">pic.twitter.com/8I5ed7nnDT</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475829444543717378?ref_src=twsrc%5Etfw">December 28, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Standards committee has approved conditional expressions
    intro: |
      @arclight The standards committee has approved conditional expressions, with 

      y = ( i&gt;=1 .And. i&lt;=Size(a) ? a(i) : -Huge(y) )

      equivalent to

      if (i&gt;=1 .And. i&lt;=Size(a)) then
         y = a(i)
      else
         y = -Huge(y)
      end if
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1475840940791279616
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The standards committee has approved conditional expressions, with <br><br>y = ( i&gt;=1 .And. i&lt;=Size(a) ? a(i) : -Huge(y) )<br><br>equivalent to<br><br>if (i&gt;=1 .And. i&lt;=Size(a)) then<br>   y = a(i)<br>else<br>   y = -Huge(y)<br>end if<a href="https://t.co/NKcB9wR2kU">https://t.co/NKcB9wR2kU</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475840940791279616?ref_src=twsrc%5Etfw">December 28, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Use .true. and .false. for Booleans, not 1 and 0
    intro: |
      Use .true. and .false. for Booleans and use the expression 

      merge(1,0,logical_variable)

      if needed. Fortran standards have never specified an equivalence between integers and Booleans.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1475905587774959616
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use .true. and .false. for Booleans and use the expression <br><br>merge(1,0,logical_variable)<br><br>if needed. Fortran standards have never specified an equivalence between integers and Booleans. <a href="https://t.co/V1ZfGdxAWT">https://t.co/V1ZfGdxAWT</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1475905587774959616?ref_src=twsrc%5Etfw">December 28, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 29-Dec-2021

  # TODO
  - title: To learn about Fortran beyond F95, read the New Features articles of John Reid
    intro: |
      To learn about Fortran beyond F95, read the 3 articles of John Reid, convenor (chairman) of the standards committee 1999-2017 on the New Features of Fortran 2018, 2008, and 2003
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1476150602866511873
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To learn about Fortran beyond F95, read the 3 articles of John Reid, convenor (chairman) of the standards committee 1999-2017 on the New Features of Fortran 2018, 2008, and 2003 <a href="https://t.co/y7bBC94ZdB">https://t.co/y7bBC94ZdB</a><a href="https://t.co/NrcHEeED8r">https://t.co/NrcHEeED8r</a><a href="https://t.co/tPtqc8BU3J">https://t.co/tPtqc8BU3J</a><br>and his co-authored book.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1476150602866511873?ref_src=twsrc%5Etfw">December 29, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: LEN of a character variable may be deferred in Fortran 2003 on
    intro: |
      The LEN of a character variable may be deferred in F2003 on.

      character (len=:), allocatable :: s,t(:)

      declares a scalar and an array of such variables. The LEN is taken from the RHS of an assignment but not from a READ. Elements of t(:) have same LEN.
    file: ~
    file0: deferred_character.f90
    url: https://twitter.com/fortrantip/status/1476201645885337611
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The LEN of a character variable may be deferred in F2003 on.<br><br>character (len=:), allocatable :: s,t(:)<br><br>declares a scalar and an array of such variables. The LEN is taken from the RHS of an assignment but not from a READ. Elements of t(:) have same LEN.<br> <a href="https://t.co/wP6lXJ3XL2">pic.twitter.com/wP6lXJ3XL2</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1476201645885337611?ref_src=twsrc%5Etfw">December 29, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Many compilers evaluate ALL(x==y) efficiently with short-circuiting
    intro: |
      For a code that evaluates ALL(x==y) with a short-circuiting function and the intrinsic, gfortran, ifort, and nvfortran seem to short-circuit the intrinsic, so it may be OK to use ALL for large expressions.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1476255945923641347
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For a code that evaluates ALL(x==y) with a short-circuiting function and the intrinsic, gfortran, ifort, and nvfortran seem to short-circuit the intrinsic, so it may be OK to use ALL for large expressions.<a href="https://t.co/n99MPh7rKt">https://t.co/n99MPh7rKt</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1476255945923641347?ref_src=twsrc%5Etfw">December 29, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Compiler Support for the Fortran 2008 and 2018 Standards
    intro: |
      @jeff_replies @axccl @OndrejCertik There is a paper "Compiler Support for the Fortran 2008 and 2018 Standards" April 2020 by Chivers &amp; Sleightholme covering Absoft Arm Cray Fujitsu gfortran IBM Intel Nag NEC Oracle PGI
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1476281645011505162
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">There is a paper &quot;Compiler Support for the Fortran 2008 and 2018 Standards&quot; April 2020 by Chivers &amp; Sleightholme covering Absoft Arm Cray Fujitsu gfortran IBM Intel Nag NEC Oracle PGI <a href="https://t.co/dPp0cZaLBs">https://t.co/dPp0cZaLBs</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1476281645011505162?ref_src=twsrc%5Etfw">December 29, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 30-Dec-2021

  # TODO
  - title: MODULO vs. MOD function
    intro: |
      Fortran has similar MODULO and MOD functions.
      MODULO (MOD) takes the sign of the 2nd (1st) argument.

      print*,modulo([-1,0,1],2)  !   1 0  1
      print*,mod([-1,0,1],2)        ! -1 0  1
      print*,modulo([-1,0,1],-2) ! -1 0 -1
      print*,mod([-1,0,1],-2)      ! -1 0   1
      end
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1476541936681066501
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran has similar MODULO and MOD functions.<br>MODULO (MOD) takes the sign of the 2nd (1st) argument.<br><br>print*,modulo([-1,0,1],2)  !   1 0  1<br>print*,mod([-1,0,1],2)        ! -1 0  1<br>print*,modulo([-1,0,1],-2) ! -1 0 -1<br>print*,mod([-1,0,1],-2)      ! -1 0   1<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1476541936681066501?ref_src=twsrc%5Etfw">December 30, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Returning multiple values from a subroutine or function
    intro: |
      Fortran cannot return multiple values with syntax like

      c, d = f(x)

      You can use a subroutine

      call f(x,c,d)

      or a function that returns a derived type containing c and d or a function that returns a size-2 array if c and d have the same type.
    file: ~
    file0: subroutine_dt.f90
    url: https://twitter.com/fortrantip/status/1476724929299197962
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran cannot return multiple values with syntax like<br><br>c, d = f(x)<br><br>You can use a subroutine<br><br>call f(x,c,d)<br><br>or a function that returns a derived type containing c and d or a function that returns a size-2 array if c and d have the same type. <a href="https://t.co/vYr5h8FsMw">pic.twitter.com/vYr5h8FsMw</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1476724929299197962?ref_src=twsrc%5Etfw">December 31, 2021</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 01-Jan-2022

  # TODO
  - title: Case insensitivity
    intro: |
      Fortran used to be written entirely in UPPERCASE, but is now case insensitive. However, whilst the following example is completely valid, to ensure legibility it's highly recommended to choose a case convention and stick to it!
    file: ~
    file0: case_insensitivity.f90
    url: https://twitter.com/fortrantip/status/1477230568781795334
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran used to be written entirely in UPPERCASE, but is now case insensitive. However, whilst the following example is completely valid, to ensure legibility it&#39;s highly recommended to choose a case convention and stick to it! <a href="https://t.co/AMXjjEVsOE">pic.twitter.com/AMXjjEVsOE</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477230568781795334?ref_src=twsrc%5Etfw">January 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Fortran-lang suggested variable naming conventions
    intro: |
      Fortran-lang Best Practices:
      1. Use lower case for all Fortran constructs, such as do, end do, if, then
      2. Follow short mathematical notation for mathematical variables/functions
      3. For other names use all lower case

      Details at
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1477282631553269764
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran-lang Best Practices:<br>1. Use lower case for all Fortran constructs, such as do, end do, if, then<br>2. Follow short mathematical notation for mathematical variables/functions<br>3. For other names use all lower case<br><br>Details at<a href="https://t.co/WHTD1MAbFq">https://t.co/WHTD1MAbFq</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477282631553269764?ref_src=twsrc%5Etfw">January 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Do case-insensitive string comparisons by converting to lower case
    intro: |
      Character variables are case-sensitive, and to compare two strings ignoring case you can first convert them to lower case.
    file: ~
    file0: lower_case.f90
    url: https://twitter.com/fortrantip/status/1477278656376590340
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Character variables are case-sensitive, and to compare two strings ignoring case you can first convert them to lower case. <a href="https://t.co/D4tnPO8tLE">pic.twitter.com/D4tnPO8tLE</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477278656376590340?ref_src=twsrc%5Etfw">January 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 02-Jan-2022

  # TODO
  - title: How size of an array function result can depend on function arguments
    intro: |
      The SIZE of a function result can be an argument, depend on an intrinsic function of an argument such as SIZE, or have an arbitrary dependence if the result is allocatable.
    file: ~
    file0: array_func.f90
    url: https://twitter.com/fortrantip/status/1477606275643019269
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The SIZE of a function result can be an argument, depend on an intrinsic function of an argument such as SIZE, or have an arbitrary dependence if the result is allocatable. <a href="https://t.co/MKlJOXn4yZ">pic.twitter.com/MKlJOXn4yZ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477606275643019269?ref_src=twsrc%5Etfw">January 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Len of character variable function result can depend on arguments
    intro: |
      The LEN of a character variable function RESULT can also depend on intrinsic functions of the arguments.
    file: ~
    file0: join.f90
    url: https://twitter.com/fortrantip/status/1477632693617799169
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The LEN of a character variable function RESULT can also depend on intrinsic functions of the arguments.  <a href="https://t.co/6vXoO79BAK">pic.twitter.com/6vXoO79BAK</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477632693617799169?ref_src=twsrc%5Etfw">January 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Advance="no" specifier of WRITE
    intro: |
      WRITE inserts a newline at the end, which can be avoided with the
      advance="no" specifier. This is useful for prompting input and reading it from the same line and for printing an unknown amount of data with one format before another format. From zoziha.
    file: ~
    file0: advance_no.f90
    url: https://twitter.com/fortrantip/status/1477788560359141382
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">WRITE inserts a newline at the end, which can be avoided with the<br>advance=&quot;no&quot; specifier. This is useful for prompting input and reading it from the same line and for printing an unknown amount of data with one format before another format. From zoziha.<a href="https://t.co/38h3L99q8Q">pic.twitter.com/38h3L99q8Q</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477788560359141382?ref_src=twsrc%5Etfw">January 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 03-Jan-2022

  # TODO
  - title: Real and integer KIND constants from iso_fortran_env; HUGE() and TINY()
    intro: |
      Module iso_fortran_env has KIND constants int8, int16, int32, int64 for integers with those storage sizes and real32, real64, real128 for reals.
      Use huge(x) and tiny(x) to get the largest and smallest numbers of type real x and huge(i) for integer i.
    file: ~
    file0: iso_kinds.f90
    url: https://twitter.com/fortrantip/status/1477985901145993221
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Module iso_fortran_env has KIND constants int8, int16, int32, int64 for integers with those storage sizes and real32, real64, real128 for reals.<br>Use huge(x) and tiny(x) to get the largest and smallest numbers of type real x and huge(i) for integer i.<a href="https://t.co/1T3srjZIsX">pic.twitter.com/1T3srjZIsX</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1477985901145993221?ref_src=twsrc%5Etfw">January 3, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: KindFinder code finds all KIND Values implemented by a compiler
    intro: |
      The KindFinder Fortran 90 code of Werner Schulz can also find
      all KIND Values implemented by a compiler, list the properties of the associated numeric models, and generate a KIND parameter module.
    file: ~
    file0: kindfind.f90
    url: https://twitter.com/fortrantip/status/1478030318485577728
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The KindFinder Fortran 90 code of Werner Schulz can also find<br>all KIND Values implemented by a compiler, list the properties of the associated numeric models, and generate a KIND parameter module.<a href="https://t.co/RY5uLdCMXl">pic.twitter.com/RY5uLdCMXl</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478030318485577728?ref_src=twsrc%5Etfw">January 3, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Fortran 2008 introduced z%re and z%im as alternatives to real(z) and aimag(z)
    intro: |
      Fortran 2008 introduced z%re and z%im as alternatives to real(z) and aimag(z) to refer to the real and imaginary parts of a complex variable z, either scalar or array. The %re and %im syntax does not apply to expressions, so (2*z)%im is disallowed.
    file: ~
    file0: im_re.f90
    url: https://twitter.com/fortrantip/status/1478160269671124993
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2008 introduced z%re and z%im as alternatives to real(z) and aimag(z) to refer to the real and imaginary parts of a complex variable z, either scalar or array. The %re and %im syntax does not apply to expressions, so (2*z)%im is disallowed. <a href="https://t.co/GcspgfI4zB">pic.twitter.com/GcspgfI4zB</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478160269671124993?ref_src=twsrc%5Etfw">January 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 04-Jan-2022

  # TODO
  - title: Use parameters to dimension fixed-size arrays to make a code easier to change
    intro: |
      Use parameters to dimension fixed-size arrays to make a code easier to change, for example

      integer, parameter :: n1=3,n2=5
      real :: x(n1,n2),y(n1,n2),z(n1,n2)

      or

      real, dimension(n1,n2) :: x,y,z

      Numbers other than 0 or 1 should not appear repeatedly and should be parameters.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1478331686412861440
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use parameters to dimension fixed-size arrays to make a code easier to change, for example<br><br>integer, parameter :: n1=3,n2=5<br>real :: x(n1,n2),y(n1,n2),z(n1,n2)<br><br>or<br><br>real, dimension(n1,n2) :: x,y,z<br><br>Numbers other than 0 or 1 should not appear repeatedly and should be parameters.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478331686412861440?ref_src=twsrc%5Etfw">January 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Avoid implicit save
    intro: |
      A variable given a value in the declaration has the implicit SAVE attribute and is not re-initialized in later calls to the procedure. Write

      integer :: i
      i = 0

      instead of 

      integer :: i = 0

      If SAVE is intended be explicit:

      integer, save :: i = 0
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1478363292028784645
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A variable given a value in the declaration has the implicit SAVE attribute and is not re-initialized in later calls to the procedure. Write<br><br>integer :: i<br>i = 0<br><br>instead of <br><br>integer :: i = 0<br><br>If SAVE is intended be explicit:<br><br>integer, save :: i = 0<a href="https://t.co/X1ZUSZblZX">pic.twitter.com/X1ZUSZblZX</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478363292028784645?ref_src=twsrc%5Etfw">January 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: KIND numbers of types are not portable across compilers and should not be used directly.
    intro: |
      KIND numbers of types are not portable across compilers and should not be used directly. It's better to use the named constants from iso_fortran_env. For both gfortran and Intel Fortran

      use iso_fortran_env
      print*,int8,int16,int32,int64

      gives 1 2 4 8, but NAG gives 1 2 3 4.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1478526602136981511
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">KIND numbers of types are not portable across compilers and should not be used directly. It&#39;s better to use the named constants from iso_fortran_env. For both gfortran and Intel Fortran<br><br>use iso_fortran_env<br>print*,int8,int16,int32,int64<br><br>gives 1 2 4 8, but NAG gives 1 2 3 4.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478526602136981511?ref_src=twsrc%5Etfw">January 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 05-Jan-2022

  # TODO
  - title: Use d0 or \_kind to make a constant double precision.
    intro: |
      Use d0 or _kind to make a constant double precision. Merely having many decimal places in a literal constant does not do so.

      real(kind(1.0d0)) :: pi
      pi = 3.14159265358979323846 ! RHS is single precision

      probably does not do what the programmer intends!
    file: ~
    file0: precision.f90
    url: https://twitter.com/fortrantip/status/1478713534850736129
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use d0 or _kind to make a constant double precision. Merely having many decimal places in a literal constant does not do so.<br><br>real(kind(1.0d0)) :: pi<br>pi = 3.14159265358979323846 ! RHS is single precision<br><br>probably does not do what the programmer intends! <a href="https://t.co/T9hNCwfcE2">pic.twitter.com/T9hNCwfcE2</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478713534850736129?ref_src=twsrc%5Etfw">January 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Use integer powers when possible.
    intro: |
      Use integer powers when possible, writing x**2 instead of x**2.0, since depending on the compiler option used, the latter may be computed as exp(2*log(x)), which is slower.
    file: ~
    file0: pow_real.f90
    url: https://twitter.com/fortrantip/status/1478765410405298176
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use integer powers when possible, writing x**2 instead of x**2.0, since depending on the compiler option used, the latter may be computed as exp(2*log(x)), which is slower. <a href="https://t.co/vlBznFvWIf">pic.twitter.com/vlBznFvWIf</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1478765410405298176?ref_src=twsrc%5Etfw">January 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 06-Jan-2022

  # TODO
  - title: Parenthesize a variable to copy it "on the fly".
    intro: |
      Parenthesize a variable to copy it "on the fly" to avoid overlapping INTENT(IN) and INTENT(OUT) arguments, which is non-standard, for example writing

      call double((i),i)

      instead of

      call double(i,i) ! bad if args are intent(in) and intent(out)
    file: ~
    file0: overlapping_arg.f90
    url: https://twitter.com/fortrantip/status/1479071485859962880
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Parenthesize a variable to copy it &quot;on the fly&quot; to avoid overlapping INTENT(IN) and INTENT(OUT) arguments, which is non-standard, for example writing<br><br>call double((i),i)<br><br>instead of<br><br>call double(i,i) ! bad if args are intent(in) and intent(out)<a href="https://t.co/WqS0AvVcCE">pic.twitter.com/WqS0AvVcCE</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1479071485859962880?ref_src=twsrc%5Etfw">January 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Substrings of character variable arrays
    intro: |
      For variables

      character (len=10) :: s, v(5)

      s(2:4) is the substring from positions 2 to 4 and v(1:3)(2:4) is an array of substrings from 
      positions 2 to 4 of the elements v(1) to v(3).
    file: ~
    file0: substring.f90
    url: https://twitter.com/fortrantip/status/1479128610623606787
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For variables<br><br>character (len=10) :: s, v(5)<br><br>s(2:4) is the substring from positions 2 to 4 and v(1:3)(2:4) is an array of substrings from <br>positions 2 to 4 of the elements v(1) to v(3). <a href="https://t.co/h5AIaZwYL2">pic.twitter.com/h5AIaZwYL2</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1479128610623606787?ref_src=twsrc%5Etfw">January 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 07-Jan-2022

  # TODO
  - title: Intrinsic character functions
    intro: |
      Character functions:

      scan(x,y): first position of a character in x found in y
      verify(x,y): first position in x NOT found in y
      index(x,y): first position of substring y in x
      adjustl/adjustr: remove leading/trailing spaces and pad to preserve LEN
    file: ~
    file0: string_func.f90
    url: https://twitter.com/fortrantip/status/1479391930744283144
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Character functions:<br><br>scan(x,y): first position of a character in x found in y<br>verify(x,y): first position in x NOT found in y<br>index(x,y): first position of substring y in x<br>adjustl/adjustr: remove leading/trailing spaces and pad to preserve LEN<a href="https://t.co/ZQZUyRq86b">pic.twitter.com/ZQZUyRq86b</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1479391930744283144?ref_src=twsrc%5Etfw">January 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Syntax for character array without manual padding
    intro: |
      Fortran 2003 lets you write an array of character variables as

      s = [character (len=4) :: "one","two","five"]

      instead of

      s = ["one ","two ","five"] ! "one" and "two" padded

      Manually padding large arrays of strings is a pain.
    file: ~
    file0: character_array.f90
    url: https://twitter.com/fortrantip/status/1479487784205402116
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2003 lets you write an array of character variables as<br><br>s = [character (len=4) :: &quot;one&quot;,&quot;two&quot;,&quot;five&quot;]<br><br>instead of<br><br>s = [&quot;one &quot;,&quot;two &quot;,&quot;five&quot;] ! &quot;one&quot; and &quot;two&quot; padded<br><br>Manually padding large arrays of strings is a pain.<a href="https://t.co/TH7x2tQ5Wz">pic.twitter.com/TH7x2tQ5Wz</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1479487784205402116?ref_src=twsrc%5Etfw">January 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Two types of syntax for defining a function
    intro: |
      Ways of defining a function:

      1. Function and result name are the same.

      2. RESULT has a different name within the function, which can be used
      to return an array.

      RETURN, when needed, is used to exit the function, not set its value.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1479641195898826754
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Ways of defining a function:<br><br>1. Function and result name are the same.<br><br>2. RESULT has a different name within the function, which can be used<br>to return an array.<br><br>RETURN, when needed, is used to exit the function, not set its value. <a href="https://t.co/TYdVDZPwCz">pic.twitter.com/TYdVDZPwCz</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1479641195898826754?ref_src=twsrc%5Etfw">January 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 08-Jan-2022

  # TODO
  - title: Propagation of an optional argument
    intro: |
      A procedure with an OPTIONAL argument can call a procedure with that argument if it is OPTIONAL there too. The PRESENT status of the argument propagates to called procedures. The optval function of the Fortran stdlib project exploits this.
    file: ~
    file0: optional_use.f90
    url: https://twitter.com/fortrantip/status/1479805991382360066
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A procedure with an OPTIONAL argument can call a procedure with that argument if it is OPTIONAL there too. The PRESENT status of the argument propagates to called procedures. The optval function of the Fortran stdlib project exploits this. <a href="https://t.co/amhSL1cbY7">pic.twitter.com/amhSL1cbY7</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1479805991382360066?ref_src=twsrc%5Etfw">January 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 09-Jan-2022

  # TODO
  - title: DIMENSION can be used to declare several arrays of the same SHAPE
    intro: |
      DIMENSION can be used to declare several arrays of the same SHAPE, which can be overridden on the same line.

      real, dimension(3,4) :: x, y, z(5,6)

      is legal but should be written

      real, dimension(3,4) :: x, y
      real :: z(5,6)

      for clarity.
    file: ~
    file0: dimension.f90
    url: https://twitter.com/fortrantip/status/1480162604559523840
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">DIMENSION can be used to declare several arrays of the same SHAPE, which can be overridden on the same line.<br><br>real, dimension(3,4) :: x, y, z(5,6)<br><br>is legal but should be written<br><br>real, dimension(3,4) :: x, y<br>real :: z(5,6)<br><br>for clarity.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1480162604559523840?ref_src=twsrc%5Etfw">January 9, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 10-Jan-2022

  # TODO
  - title: UnALLOCATED variable passed to a procedure is not PRESENT there.
    intro: |
      A variable that is not ALLOCATED, when passed as an OPTIONAL, non-allocatable argument to a procedure, is considered not PRESENT there. This Fortran 2008 feature can simplify code.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1480585104997163018
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A variable that is not ALLOCATED, when passed as an OPTIONAL, non-allocatable argument to a procedure, is considered not PRESENT there. This Fortran 2008 feature can simplify code. <a href="https://t.co/TdSd5Jv0Pt">https://t.co/TdSd5Jv0Pt</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1480585104997163018?ref_src=twsrc%5Etfw">January 10, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 11-Jan-2022

  # TODO
  - title: Procedures can be called with a mix of named and positional arguments.
    intro: |
      Procedures can be called with a mix of named and positional arguments, but positional arguments cannot follow named ones. Naming arguments makes it easier to add arguments without breaking code. It's good to
      name OPTIONAL arguments.
    file: ~
    file0: arguments.f90
    url: https://twitter.com/fortrantip/status/1480893840068390913
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Procedures can be called with a mix of named and positional arguments, but positional arguments cannot follow named ones. Naming arguments makes it easier to add arguments without breaking code. It&#39;s good to<br>name OPTIONAL arguments.<a href="https://t.co/rIl2jM0DTA">pic.twitter.com/rIl2jM0DTA</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1480893840068390913?ref_src=twsrc%5Etfw">January 11, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 12-Jan-2022

  # TODO
  - title: Use the same name for analogous procedures defined in different modules using an INTERFACE
    intro: |
      Using an INTERFACE, one can use the same name for analogous procedures that operate on derived types defined in different modules, for example str to convert a derived type to a string.
    file: ~
    file0: shared_interface.f90
    url: https://twitter.com/fortrantip/status/1481247763048407042
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Using an INTERFACE, one can use the same name for analogous procedures that operate on derived types defined in different modules, for example str to convert a derived type to a string.<a href="https://t.co/VeqDzgg5AE">pic.twitter.com/VeqDzgg5AE</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1481247763048407042?ref_src=twsrc%5Etfw">January 12, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 13-Jan-2022

  # TODO
  - title: How to rename an imported module entity
    intro: |
      An imported module entity can be renamed with the syntax

      use mod, only: local_name =&gt; use_name

      or

      use mod, local_name =&gt; use_name

      This is necessary when importing procedures with the same name, not in interfaces, from different
      modules.
    file: ~
    file0: rename.f90
    url: https://twitter.com/fortrantip/status/1481597325499842563
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An imported module entity can be renamed with the syntax<br><br>use mod, only: local_name =&gt; use_name<br><br>or<br><br>use mod, local_name =&gt; use_name<br><br>This is necessary when importing procedures with the same name, not in interfaces, from different<br>modules. <a href="https://t.co/89mRx3jsWV">pic.twitter.com/89mRx3jsWV</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1481597325499842563?ref_src=twsrc%5Etfw">January 13, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 14-Jan-2022

  # TODO
  - title: Module entities are PUBLIC by default.
    intro: |
      Module entities are PUBLIC by default, but if a blank PRIVATE statement is used, any public entities must be labeled so explicitly. Doing this clarifies what is exported from the module.
    file: ~
    file0: private.f90
    url: https://twitter.com/fortrantip/status/1481970740475932676
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Module entities are PUBLIC by default, but if a blank PRIVATE statement is used, any public entities must be labeled so explicitly. Doing this clarifies what is exported from the module.<a href="https://t.co/4eJZDbU7CZ">pic.twitter.com/4eJZDbU7CZ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1481970740475932676?ref_src=twsrc%5Etfw">January 14, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 15-Jan-2022

  # TODO
  - title: An unqualified USE foo statement imports public entities defined in foo and what foo imported.
    intro: |
      use foo

      imports not only the public entities defined in module foo but also the entities that foo imports from module bar. To avoid inadvertent imports and clarify what is imported, write

      use foo, only: &lt;imports&gt;
      use bar, only: &lt;imports&gt; ! if any
    file: ~
    file0: imports.f90
    url: https://twitter.com/fortrantip/status/1482328990798987266
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">use foo<br><br>imports not only the public entities defined in module foo but also the entities that foo imports from module bar. To avoid inadvertent imports and clarify what is imported, write<br><br>use foo, only: &lt;imports&gt;<br>use bar, only: &lt;imports&gt; ! if any<a href="https://t.co/9s78tF1V5Q">pic.twitter.com/9s78tF1V5Q</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1482328990798987266?ref_src=twsrc%5Etfw">January 15, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 16-Jan-2022

  # TODO
  - title: Use iostat and iomsg to handle READ errors
    intro: |
      The Fortran 2003 module iso_fortran_env has constants 

      iostat_eor -- end of record
      iostat_end -- end of file

      to which the iostat of a READ statement will be set if that error occurs. READ also has an iomsg specifier returning a text error message.
    file: ~
    file0: iomsg.f90
    url: https://twitter.com/fortrantip/status/1482687630877892608
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The Fortran 2003 module iso_fortran_env has constants <br><br>iostat_eor -- end of record<br>iostat_end -- end of file<br><br>to which the iostat of a READ statement will be set if that error occurs. READ also has an iomsg specifier returning a text error message.<a href="https://t.co/Rm6DmsKPP9">pic.twitter.com/Rm6DmsKPP9</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1482687630877892608?ref_src=twsrc%5Etfw">January 16, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: List of Fortran compilers, build tools, text editors, etc.
    intro: |
      I keep a list of Fortran compilers, build tools, text editors and plug-ins, linters, preprocessors, translators to and from Fortran, profilers, tools for refactoring, interoperability, and automatic documentation, and unit testing frameworks.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1482709817466707969
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I keep a list of Fortran compilers, build tools, text editors and plug-ins, linters, preprocessors, translators to and from Fortran, profilers, tools for refactoring, interoperability, and automatic documentation, and unit testing frameworks.<a href="https://t.co/fnWwF04z5D">https://t.co/fnWwF04z5D</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1482709817466707969?ref_src=twsrc%5Etfw">January 16, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 17-Jan-2022

  # TODO
  - title: Fortran 2008 introduced IMPURE ELEMENTAL procedures
    intro: |
      Fortran 2008 allows procedures to be labeled IMPURE ELEMENTAL. Such procedures can do external I/O and have a STOP or ERROR STOP statement. They can simulate a loop over a collection. The plain ELEMENTAL designation means the same as PURE ELEMENTAL.
    file: ~
    file0: impure_elemental.f90
    url: https://twitter.com/fortrantip/status/1483063464562204672
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2008 allows procedures to be labeled IMPURE ELEMENTAL. Such procedures can do external I/O and have a STOP or ERROR STOP statement. They can simulate a loop over a collection. The plain ELEMENTAL designation means the same as PURE ELEMENTAL.<a href="https://t.co/e5Z6K7MvvC">pic.twitter.com/e5Z6K7MvvC</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1483063464562204672?ref_src=twsrc%5Etfw">January 17, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-Jan-2022

  # TODO
  - title: Impure elemental procedure can be used to generate array of non-uniform variates
    intro: |
      The RANDOM_NUMBER intrinsic returns a scalar or an array of uniform variates. An impure elemental subroutine can do the same for normal variates, given an algorithm to generate a single normal variate, possibly using RANDOM_NUMBER.
    file: ~
    file0: random_normal.f90
    url: https://twitter.com/fortrantip/status/1483430581232967684
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The RANDOM_NUMBER intrinsic returns a scalar or an array of uniform variates. An impure elemental subroutine can do the same for normal variates, given an algorithm to generate a single normal variate, possibly using RANDOM_NUMBER.<a href="https://t.co/udthsbMT7T">pic.twitter.com/udthsbMT7T</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1483430581232967684?ref_src=twsrc%5Etfw">January 18, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-Jan-2022

  # TODO
  - title: Array constructor with [] was introduced in Fortran 2003. Still valid is (//)
    intro: |
      Using [] for an array constructor was introduced in Fortran 2003, although many Fortran 95 compilers supported it. The older syntax (//) is still valid.

      print*, all([4,9] == (/4,9/)) ! T
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1483773578839474180
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Using [] for an array constructor was introduced in Fortran 2003, although many Fortran 95 compilers supported it. The older syntax (//) is still valid.<br><br>print*, all([4,9] == (/4,9/)) ! T</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1483773578839474180?ref_src=twsrc%5Etfw">January 19, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-Jan-2022

  # TODO
  - title: PROTECTED module variables cannot be changed outside the module.
    intro: |
      If a module variable is PROTECTED, an attribute introduced in Fortran 2003, it can only be modified by a procedure in the module where it is declared. It is useful for PUBLIC module variables that can be accessed but should not changed outside the module.
    file: ~
    file0: protected.f90
    url: https://twitter.com/fortrantip/status/1484136749924245509
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If a module variable is PROTECTED, an attribute introduced in Fortran 2003, it can only be modified by a procedure in the module where it is declared. It is useful for PUBLIC module variables that can be accessed but should not changed outside the module.<a href="https://t.co/HoABECoBdO">pic.twitter.com/HoABECoBdO</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1484136749924245509?ref_src=twsrc%5Etfw">January 20, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 21-Jan-2022

  # TODO
  - title: Use INTRINSIC to specify that compiler-provided procedures and modules are referenced
    intro: |
      You can supply procedures and modules with the same names as intrinsics. To specify that the intrinsic procedure or module provided by the compiler is used write

      use, intrinsic :: iso_fortran_env
      intrinsic :: sin
    file: ~
    file0: intrinsic.f90
    url: https://twitter.com/fortrantip/status/1484517091738886147
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">You can supply procedures and modules with the same names as intrinsics. To specify that the intrinsic procedure or module provided by the compiler is used write<br><br>use, intrinsic :: iso_fortran_env<br>intrinsic :: sin <a href="https://t.co/NydDt6a9eD">pic.twitter.com/NydDt6a9eD</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1484517091738886147?ref_src=twsrc%5Etfw">January 21, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 22-Jan-2022

  # TODO
  - title: VALUE attribute for procedure arguments introduced in Fortran 2003
    intro: |
      If an argument has the VALUE attribute, added in Fortran 2003, changes to the dummy argument in the procedure do not change the actual argument in the the caller.
    file: ~
    file0: value.f90
    url: https://twitter.com/fortrantip/status/1484874794352918528
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If an argument has the VALUE attribute, added in Fortran 2003, changes to the dummy argument in the procedure do not change the actual argument in the the caller.<a href="https://t.co/SVdZjbaw5v">pic.twitter.com/SVdZjbaw5v</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1484874794352918528?ref_src=twsrc%5Etfw">January 22, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 23-Jan-2022

  # TODO
  - title: Turn compiler warnings into errors to force code defects to be fixed.
    intro: |
      To ensure that code defects are fixed, use options to turn the relevant compiler warnings into errors in the build system. For example

      gfortran -Werror=unused-variable -Werror=unused-function

      rejects the code below. Mere warnings are often ignored.
    file: ~
    file0: warnings.f90
    url: https://twitter.com/fortrantip/status/1485235396179079173
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To ensure that code defects are fixed, use options to turn the relevant compiler warnings into errors in the build system. For example<br><br>gfortran -Werror=unused-variable -Werror=unused-function<br><br>rejects the code below. Mere warnings are often ignored.<a href="https://t.co/OiYA1EWwcj">pic.twitter.com/OiYA1EWwcj</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1485235396179079173?ref_src=twsrc%5Etfw">January 23, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 24-Jan-2022

  # TODO
  - title: An INTENT(OUT) argument is undefined at the beginning of a procedure
    intro: |
      A non-allocatable INTENT(OUT) dummy argument is undefined at the beginning of a procedure. Although most compilers will set it to the value of the actual argument, you should declare the argument 
      INTENT(IN OUT) to mandate this behavior.
    file: ~
    file0: intent_out_undefined.f90
    url: https://twitter.com/fortrantip/status/1485594671300632576
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A non-allocatable INTENT(OUT) dummy argument is undefined at the beginning of a procedure. Although most compilers will set it to the value of the actual argument, you should declare the argument <br>INTENT(IN OUT) to mandate this behavior. <a href="https://t.co/3dLZA7aWwP">pic.twitter.com/3dLZA7aWwP</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1485594671300632576?ref_src=twsrc%5Etfw">January 24, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 25-Jan-2022

  # TODO
  - title: ALLOCATABLE INTENT(OUT) argument is deallocated.
    intro: |
      An ALLOCATABLE INTENT(OUT) dummy argument is deallocated at the beginning of a procedure, as are the ALLOCATABLE components of an INTENT(OUT) derived type.
    file: ~
    file0: intent_out_allocatable.f90
    url: https://twitter.com/fortrantip/status/1485957543990018053
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An ALLOCATABLE INTENT(OUT) dummy argument is deallocated at the beginning of a procedure, as are the ALLOCATABLE components of an INTENT(OUT) derived type.<a href="https://t.co/gtBVzGD0nv">pic.twitter.com/gtBVzGD0nv</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1485957543990018053?ref_src=twsrc%5Etfw">January 25, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 26-Jan-2022

  # TODO
  - title: Dummy argument that is changed must be definable in the caller.
    intro: |
      If a dummy argument without the VALUE attribute is changed in a procedure, the actual argument must be definable in the caller -- a variable, not a constant or expression.
    file: ~
    file0: definable_arg.f90
    url: https://twitter.com/fortrantip/status/1486313053092208645
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If a dummy argument without the VALUE attribute is changed in a procedure, the actual argument must be definable in the caller -- a variable, not a constant or expression.<a href="https://t.co/cpxhod0nN7">pic.twitter.com/cpxhod0nN7</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1486313053092208645?ref_src=twsrc%5Etfw">January 26, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 27-Jan-2022

  # TODO
  - title: IEEE_ARITHMETIC module has functions to test numerical conditions.
    intro: |
      Fortran 2003 introduced an ieee_arithmetic module with elemental functions ieee_is_nan, ieee_is_finite, 
      ieee_is_negative, and ieee_is_normal, which test for those conditions. They have a real argument and logical RESULT.
    file: ~
    file0: ieee_arithmetic.f90
    url: https://twitter.com/fortrantip/status/1486706121335263246
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2003 introduced an ieee_arithmetic module with elemental functions ieee_is_nan, ieee_is_finite, <br>ieee_is_negative, and ieee_is_normal, which test for those conditions. They have a real argument and logical RESULT.<a href="https://t.co/82On9iDxXQ">pic.twitter.com/82On9iDxXQ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1486706121335263246?ref_src=twsrc%5Etfw">January 27, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 28-Jan-2022

  # TODO
  - title: Call ieee_set_halting_mode() to set floating point conditions that halt program.
    intro: |
      Call ieee_set_halting_mode() of F2003 module ieee_exceptions to set the floating point conditions (NaN, overflow, underflow, divide-by-zero, inexact) that will halt a program. Similar compiler options include 
      gfortran -ffpe-trap=invalid
      ifort -fpe0.
    file: ~
    file0: ieee_exceptions.f90
    url: https://twitter.com/fortrantip/status/1487084606780325889
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Call ieee_set_halting_mode() of F2003 module ieee_exceptions to set the floating point conditions (NaN, overflow, underflow, divide-by-zero, inexact) that will halt a program. Similar compiler options include <br>gfortran -ffpe-trap=invalid<br>ifort -fpe0.<a href="https://t.co/gHjgCZMQU0">pic.twitter.com/gHjgCZMQU0</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1487084606780325889?ref_src=twsrc%5Etfw">January 28, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 29-Jan-2022

  # TODO
  - title: A procedure can have an argument that is another PROCEDURE with an INTERFACE.
    intro: |
      A procedure can have an argument that is another PROCEDURE with an INTERFACE, which is useful for writing a procedure that minimizes or integrates a function.
    file: ~
    file0: trapezoid.f90
    url: https://twitter.com/fortrantip/status/1487410814919356419
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A procedure can have an argument that is another PROCEDURE with an INTERFACE, which is useful for writing a procedure that minimizes or integrates a function.<a href="https://t.co/NtVYKTbltS">pic.twitter.com/NtVYKTbltS</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1487410814919356419?ref_src=twsrc%5Etfw">January 29, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Google foo filetype:f90 or foo filetype:f to find Fortran code with foo.
    intro: |
      Since Fortran source files usually have the .f90 or .f suffix, you can Google, for example, "finite element" filetype:f90 and "finite element" filetype:f to find finite element codes.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1487557071818084357
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Since Fortran source files usually have the .f90 or .f suffix, you can Google, for example, &quot;finite element&quot; filetype:f90 and &quot;finite element&quot; filetype:f to find finite element codes.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1487557071818084357?ref_src=twsrc%5Etfw">January 29, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 30-Jan-2022

  # TODO
  - title: Polyhedron suggested compiler optimization options and Fortran 95 benchmarks
    intro: |
      Polyhedron has suggested compiler options for optimization and compared compiler speed on some Fortran 95 codes.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1487791193710866437
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Polyhedron has suggested compiler options for optimization and compared compiler speed on some Fortran 95 codes. <a href="https://t.co/3zrgBY9TPM">https://t.co/3zrgBY9TPM</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1487791193710866437?ref_src=twsrc%5Etfw">January 30, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 31-Jan-2022

  # TODO
  - title: Vector subscript can be used for non-contiguous array sections.
    intro: |
      A vector subscript can be used for non-contiguous array sections, for example 

      real :: x(5)
      print*,x([2,4])

      An array section with a vector subscript cannot be passed as an intent(out) or intent(in out) argument.
    file: ~
    file0: vector_subscript.f90
    url: https://twitter.com/fortrantip/status/1488132722761609216
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A vector subscript can be used for non-contiguous array sections, for example <br><br>real :: x(5)<br>print*,x([2,4])<br><br>An array section with a vector subscript cannot be passed as an intent(out) or intent(in out) argument. <a href="https://t.co/kTdDGksivR">pic.twitter.com/kTdDGksivR</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1488132722761609216?ref_src=twsrc%5Etfw">January 31, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 01-Feb-2022

  # TODO
  - title: Setting the values of an array section
    intro: |
      Fortran array indices must be integers, so you cannot write

      v(v&lt;0) = -1

      as in R, but alternatives are

      where (v&lt;0) v = -1
      v = merge(-1,v,v&lt;0)
      v(truloc(v&lt;0)) = -1

      where truloc is a user function that creates a vector subscript from a logical mask.
    file: ~
    file0: truloc.f90
    url: https://twitter.com/fortrantip/status/1488492649166295043
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran array indices must be integers, so you cannot write<br><br>v(v&lt;0) = -1<br><br>as in R, but alternatives are<br><br>where (v&lt;0) v = -1<br>v = merge(-1,v,v&lt;0)<br>v(truloc(v&lt;0)) = -1<br><br>where truloc is a user function that creates a vector subscript from a logical mask.<a href="https://t.co/Z8BM3iUNOF">pic.twitter.com/Z8BM3iUNOF</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1488492649166295043?ref_src=twsrc%5Etfw">February 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 02-Feb-2022

  # TODO
  - title: Mistakes in Fortran 90 Programs That Might Surprise You, by Szymanski
    intro: |
      Here is a a survey of Fortran 90 pitfalls. Most are still relevant, but now
      (1) Derived types can have allocatable components.
      (2) A pointer can be initialized to null() in the
      declaration.
      (3) Stream I/O is an alternative to record-based I/O.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1488844789575569408
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Here is a a survey of Fortran 90 pitfalls. Most are still relevant, but now<br>(1) Derived types can have allocatable components.<br>(2) A pointer can be initialized to null() in the<br>declaration.<br>(3) Stream I/O is an alternative to record-based I/O.<a href="https://t.co/P4tRJyN0Y6">https://t.co/P4tRJyN0Y6</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1488844789575569408?ref_src=twsrc%5Etfw">February 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 03-Feb-2022

  # TODO
  - title: Execute_command_line() to pass a command to the shell.
    intro: |
      execute_command_line(command [,wait,exitstat]) is a Fortran 2008 subroutine that issues a command to the shell and returns the exit code exitstat of the command. The program pauses until the command is finished unless wait is PRESENT and .FALSE.
    file: ~
    file0: execute.f90
    url: https://twitter.com/fortrantip/status/1489212898777964545
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">execute_command_line(command [,wait,exitstat]) is a Fortran 2008 subroutine that issues a command to the shell and returns the exit code exitstat of the command. The program pauses until the command is finished unless wait is PRESENT and .FALSE.<a href="https://t.co/XF3s5THxv8">pic.twitter.com/XF3s5THxv8</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1489212898777964545?ref_src=twsrc%5Etfw">February 3, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 04-Feb-2022

  # TODO
  - title: Execute_command_line() can call gnuplot to display a plot during a run.
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1489580579653918729
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/UW5eVxka7J">https://t.co/UW5eVxka7J</a> <br>execute_command_line() can call gnuplot to display a plot during a run, as done in GitHub project ogpf. Another use is execute_command_line(&quot;ls data/*.csv &gt; list.txt&quot;) to create a list of files to process.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1489580579653918729?ref_src=twsrc%5Etfw">February 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 05-Feb-2022

  # TODO
  - title: Document results with compiler_version(), compiler_options(), and other intrinsics.
    intro: |
      To document results use get_command_argument(0,name) to get the
      executable name, compiler_version() and compiler_options() to get the compiler and options used, date_and_time() for the time, and cpu_time() or system_clock() for time elapsed.
    file: ~
    file0: xpi.f90
    url: https://twitter.com/fortrantip/status/1489952805649588226
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To document results use get_command_argument(0,name) to get the<br>executable name, compiler_version() and compiler_options() to get the compiler and options used, date_and_time() for the time, and cpu_time() or system_clock() for time elapsed.<a href="https://t.co/ag8p4ipIqN">pic.twitter.com/ag8p4ipIqN</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1489952805649588226?ref_src=twsrc%5Etfw">February 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 06-Feb-2022

  # TODO
  - title: Demonstrate subroutine get_environment_variable(name,value) of Fortran 2003.
    intro: |
      Subroutine get_environment_variable(name,value) of Fortran 2003 returns the value of an environment variable or a blank string if it does not exist. The user
      and computer name can be added to results, and whether the OS is Windows or Unix can be queried.
    file: ~
    file0: get_env.f90
    url: https://twitter.com/fortrantip/status/1490329749578731530
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Subroutine get_environment_variable(name,value) of Fortran 2003 returns the value of an environment variable or a blank string if it does not exist. The user<br>and computer name can be added to results, and whether the OS is Windows or Unix can be queried.<a href="https://t.co/ctMhn0nXwl">pic.twitter.com/ctMhn0nXwl</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1490329749578731530?ref_src=twsrc%5Etfw">February 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 07-Feb-2022

  # TODO
  - title: get_command() and get_command_argument() get command line arguments.
    intro: |
      In Fortran 2003, get_command(command) and
      get_command_argument(number,value) are subroutines to get the entire command line or the nth argument as character variables, and the function command_argument_count() returns the number of arguments.
    file: ~
    file0: get_command.f90
    url: https://twitter.com/fortrantip/status/1490666160504905730
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In Fortran 2003, get_command(command) and<br>get_command_argument(number,value) are subroutines to get the entire command line or the nth argument as character variables, and the function command_argument_count() returns the number of arguments.<a href="https://t.co/TfCZ8dzn5R">pic.twitter.com/TfCZ8dzn5R</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1490666160504905730?ref_src=twsrc%5Etfw">February 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 08-Feb-2022

  # TODO
  - title: Concatenate arrays and scalars in an array constructor []
    intro: |
      A mix of arrays and scalars can be concatenated to a 1D array by putting them in an array constructor. Each array is flattened in column-major order to a 1D array.
      Columns can be added to a matrix using RESHAPE on a concatenation.
    file: ~
    file0: concatenate.f90
    url: https://twitter.com/fortrantip/status/1491021968799600641
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A mix of arrays and scalars can be concatenated to a 1D array by putting them in an array constructor. Each array is flattened in column-major order to a 1D array.<br>Columns can be added to a matrix using RESHAPE on a concatenation. <a href="https://t.co/43bpTzHDTy">pic.twitter.com/43bpTzHDTy</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1491021968799600641?ref_src=twsrc%5Etfw">February 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 09-Feb-2022

  # TODO
  - title: spread(source, dim, ncopies) copies a SOURCE array NCOPIES times along dimension DIM.
    intro: |
      spread(source, dim, ncopies) copies a SOURCE array NCOPIES times along dimension DIM, creating an array one rank higher than SOURCE. It can be applied to a vector to get a result that is conformable with a matrix.
    file: ~
    file0: spread.f90
    url: https://twitter.com/fortrantip/status/1491380119616700417
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">spread(source, dim, ncopies) copies a SOURCE array NCOPIES times along dimension DIM, creating an array one rank higher than SOURCE. It can be applied to a vector to get a result that is conformable with a matrix.<a href="https://t.co/gZRvWZckGz">pic.twitter.com/gZRvWZckGz</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1491380119616700417?ref_src=twsrc%5Etfw">February 9, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 10-Feb-2022

  # TODO
  - title: Convert from strings to numbers and the reverse using internal READ and WRITE.
    intro: |
      Type conversion from strings to numbers and vice-versa is most commonly done with internal reads and writes. You can read from and write to a character variable as with a file. You cannot write to an unallocated deferred-length character variable.
    file: ~
    file0: internal_read_write.f90
    url: https://twitter.com/fortrantip/status/1491754652030885888
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Type conversion from strings to numbers and vice-versa is most commonly done with internal reads and writes. You can read from and write to a character variable as with a file. You cannot write to an unallocated deferred-length character variable.<a href="https://t.co/wE0gLrf41d">pic.twitter.com/wE0gLrf41d</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1491754652030885888?ref_src=twsrc%5Etfw">February 10, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 11-Feb-2022

  # TODO
  - title: Internal write to character variable too small to hold output causes run-time error.
    intro: |
      A character variable can be assigned to a character variable with smaller or larger LEN, resulting in padding with blanks or truncation, but an internal write to a character variable that is too small to hold the output will cause a run-time error.
    file: ~
    file0: write_char.f90
    url: https://twitter.com/fortrantip/status/1492114908351283206
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A character variable can be assigned to a character variable with smaller or larger LEN, resulting in padding with blanks or truncation, but an internal write to a character variable that is too small to hold the output will cause a run-time error. <a href="https://t.co/4wW4hTYTHS">pic.twitter.com/4wW4hTYTHS</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1492114908351283206?ref_src=twsrc%5Etfw">February 11, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 12-Feb-2022

  # TODO
  - title: Character variables can be compared like numerical variables.
    intro: |
      The comparison operators &lt; &lt;= etc. or .lt. .le. etc. can be used for character variables, usually with the ASCII collating sequence. The lexical comparison functions LLT, LLE, LGE, LGT use this sequence. MINVAL, MINLOC, FINDLOC work on arrays of strings.
    file: ~
    file0: compare_character.f90
    url: https://twitter.com/fortrantip/status/1492489511821004805
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The comparison operators &lt; &lt;= etc. or .lt. .le. etc. can be used for character variables, usually with the ASCII collating sequence. The lexical comparison functions LLT, LLE, LGE, LGT use this sequence. MINVAL, MINLOC, FINDLOC work on arrays of strings. <a href="https://t.co/fymX8ecd4j">pic.twitter.com/fymX8ecd4j</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1492489511821004805?ref_src=twsrc%5Etfw">February 12, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 13-Feb-2022

  # TODO
  - title: How to reverse an array or character string
    intro: |
      Write

      v = v(size(v):1:-1)

      to reverse a 1-D array v with lower bound 1, otherwise

      v = v(ubound(v):lbound(v):-1)

      v(::-1) is a zero-size array unless size(v) = 1. A character string can be reversed with the function shown.
    file: ~
    file0: reverse.f90
    url: https://twitter.com/fortrantip/status/1492844114492243971
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Write<br><br>v = v(size(v):1:-1)<br><br>to reverse a 1-D array v with lower bound 1, otherwise<br><br>v = v(ubound(v):lbound(v):-1)<br><br>v(::-1) is a zero-size array unless size(v) = 1. A character string can be reversed with the function shown. <a href="https://t.co/ngOUfICgvf">pic.twitter.com/ngOUfICgvf</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1492844114492243971?ref_src=twsrc%5Etfw">February 13, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 14-Feb-2022

  # TODO
  - title: Array lower bounds are not preserved when passed as assumed shape argument.
    intro: |
      The lower bounds of an assumed shape dummy argument are 1 or the lower bounds specified in the procedure declaration, regardless of the lower bounds of actual argument in the caller. The lower bounds can be passed as arguments.
    file: ~
    file0: lbound_assumed_shape.f90
    url: https://twitter.com/fortrantip/status/1493207320184164352
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The lower bounds of an assumed shape dummy argument are 1 or the lower bounds specified in the procedure declaration, regardless of the lower bounds of actual argument in the caller. The lower bounds can be passed as arguments.<a href="https://t.co/wRauYCI75B">pic.twitter.com/wRauYCI75B</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1493207320184164352?ref_src=twsrc%5Etfw">February 14, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Bounds of a derived type array component are preserved when passed to procedure.
    intro: |
      The bounds of a derived type array component are preserved when the whole derived type is passed to a procedure, as shown in the code of the previous tip.
    file: ~
    file0: lbound_assumed_shape.f90
    url: https://twitter.com/fortrantip/status/1493214664754438149
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The bounds of a derived type array component are preserved when the whole derived type is passed to a procedure, as shown in the code of the previous tip.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1493214664754438149?ref_src=twsrc%5Etfw">February 14, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 15-Feb-2022

  # TODO
  - title: Bounds of an allocatable array are preserved when passed to an allocatable, intent(in) or intent(in out) argument.
    intro: |
      The bounds of an allocatable array are preserved when passed to an allocatable, intent(in) or intent(in out) argument in a procedure. The same is true for intent(in) or intent(in out) pointer array arguments.
    file: ~
    file0: allocatable_bounds.f90
    url: https://twitter.com/fortrantip/status/1493569929668354051
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The bounds of an allocatable array are preserved when passed to an allocatable, intent(in) or intent(in out) argument in a procedure. The same is true for intent(in) or intent(in out) pointer array arguments.<a href="https://t.co/2S43P7demh">pic.twitter.com/2S43P7demh</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1493569929668354051?ref_src=twsrc%5Etfw">February 15, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 16-Feb-2022

  # TODO
  - title: Modern Fortran Reference Card and Quick Reference/Cheat Sheet.
    intro: |
      Modern Fortran Reference Card of Michael Goerz crams a lot of good information in 2 pages
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1493920435997659145
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Modern Fortran Reference Card of Michael Goerz crams a lot of good information in 2 pages<a href="https://t.co/QzVEZpfe1Z">https://t.co/QzVEZpfe1Z</a>, as does the 5-page Quick Reference/Cheat Sheet of Ben Evans <a href="https://t.co/HDt5B4Swe4">https://t.co/HDt5B4Swe4</a>.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1493920435997659145?ref_src=twsrc%5Etfw">February 16, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 17-Feb-2022

  # TODO
  - title: A derived type can be used where a scalar is needed.
    intro: |
      A derived type variable is a scalar even if it has array components. Arrays of varying-length strings or pointers can be simulated. A derived type can be used where a scalar is required, for example as the dummy argument of an elemental procedure.
    file: ~
    file0: elemental_func_arg.f90
    url: https://twitter.com/fortrantip/status/1494295438320713730
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A derived type variable is a scalar even if it has array components. Arrays of varying-length strings or pointers can be simulated. A derived type can be used where a scalar is required, for example as the dummy argument of an elemental procedure.<a href="https://t.co/QMUCesqyVR">pic.twitter.com/QMUCesqyVR</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1494295438320713730?ref_src=twsrc%5Etfw">February 17, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-Feb-2022

  # TODO
  - title: A derived type can have derived type components.
    intro: |
      A derived type may have components that are also derived types. If x is an instance of a derived type that has component y, and y has component z, you can write x%y%z to access z. A similar syntax applies with type extension of Fortran 2003.
    file: ~
    file0: derived_type_composition.f90
    url: https://twitter.com/fortrantip/status/1494651022010200065
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A derived type may have components that are also derived types. If x is an instance of a derived type that has component y, and y has component z, you can write x%y%z to access z. A similar syntax applies with type extension of Fortran 2003.<a href="https://t.co/xCLrAss3hf">pic.twitter.com/xCLrAss3hf</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1494651022010200065?ref_src=twsrc%5Etfw">February 18, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-Feb-2022

  # TODO
  - title: A derived type component can have a default value.
    intro: |
      If a derived type component is given a default value, the default constructor can be called without setting that component, which takes that value.
    file: ~
    file0: type_constructor_optional.f90
    url: https://twitter.com/fortrantip/status/1495001410894811139
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If a derived type component is given a default value, the default constructor can be called without setting that component, which takes that value.<a href="https://t.co/xQ8uWiZU52">pic.twitter.com/xQ8uWiZU52</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1495001410894811139?ref_src=twsrc%5Etfw">February 19, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-Feb-2022

  # TODO
  - title: A derived type can have PRIVATE components.
    intro: |
      Derived type components can be declared PRIVATE, in which case they are only visible in the module where the type is defined. Below, b is private and c is public.

      type dt
        private
        real :: b
        real, public :: c ! override private
      end type
    file: ~
    file0: dt_private.f90
    url: https://twitter.com/fortrantip/status/1495372934537428997
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Derived type components can be declared PRIVATE, in which case they are only visible in the module where the type is defined. Below, b is private and c is public.<br><br>type dt<br>  private<br>  real :: b<br>  real, public :: c ! override private<br>end type <a href="https://t.co/TD76teqpzi">pic.twitter.com/TD76teqpzi</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1495372934537428997?ref_src=twsrc%5Etfw">February 20, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 21-Feb-2022

  # TODO
  - title: storage_size(A) returns the storage size of argument A in bits.
    intro: |
      storage_size(A) is an F2008 function that returns the storage size of argument A in bits. If A is an array it returns the size of an element of A. If A is a derived type with allocatable components, the result of storage_size() is compiler-dependent.
    file: ~
    file0: storage_size.f90
    url: https://twitter.com/fortrantip/status/1495738404356689926
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">storage_size(A) is an F2008 function that returns the storage size of argument A in bits. If A is an array it returns the size of an element of A. If A is a derived type with allocatable components, the result of storage_size() is compiler-dependent.<a href="https://t.co/p5bobsQXUj">pic.twitter.com/p5bobsQXUj</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1495738404356689926?ref_src=twsrc%5Etfw">February 21, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 22-Feb-2022

  # TODO
  - title: Fortran 2018 procedures can have assumed-rank arguments.
    intro: |
      Fortran 2018 procedures with explicit interfaces can have assumed-rank arguments, denoted x(..), that can be scalars or arrays of arbitrary rank. Within the procedure the SELECT RANK construct and RANK intrinsic is used to handle each rank.
    file: ~
    file0: assumed_rank.f90
    url: https://twitter.com/fortrantip/status/1496107321457528835
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2018 procedures with explicit interfaces can have assumed-rank arguments, denoted x(..), that can be scalars or arrays of arbitrary rank. Within the procedure the SELECT RANK construct and RANK intrinsic is used to handle each rank.<a href="https://t.co/Hzqt5e1H9r">pic.twitter.com/Hzqt5e1H9r</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1496107321457528835?ref_src=twsrc%5Etfw">February 22, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 23-Feb-2022

  # TODO
  - title: Unlimited polymorphic allocatable variable can be set to any type.
    intro: |
      An unlimited polymorphic allocatable variable x

      class(*), allocatable :: x

      can hold any type of variable or object. It can be passed as a class(*) argument. Otherwise it must be disambiguated with SELECT TYPE before being used.
    file: ~
    file0: unlimited_poly.f90
    url: https://twitter.com/fortrantip/status/1496463950375960579
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An unlimited polymorphic allocatable variable x<br><br>class(*), allocatable :: x<br><br>can hold any type of variable or object. It can be passed as a class(*) argument. Otherwise it must be disambiguated with SELECT TYPE before being used.<a href="https://t.co/gYj2OMhwQj">pic.twitter.com/gYj2OMhwQj</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1496463950375960579?ref_src=twsrc%5Etfw">February 23, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Unlimited polymorphic pointer can point to any type.
    intro: |
      An unlimited polymorphic pointer p

      class(*), pointer :: p

      can point to any type of variable or object and can be passed as a class(*) or class(*), pointer argument. Otherwise it must be disambiguated with SELECT TYPE before being used.
    file: ~
    file0: unlimited_pointer.f90
    url: https://twitter.com/fortrantip/status/1496470666576642048
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An unlimited polymorphic pointer p<br><br>class(*), pointer :: p<br><br>can point to any type of variable or object and can be passed as a class(*) or class(*), pointer argument. Otherwise it must be disambiguated with SELECT TYPE before being used.<a href="https://t.co/AJaPqr1rBF">pic.twitter.com/AJaPqr1rBF</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1496470666576642048?ref_src=twsrc%5Etfw">February 23, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 24-Feb-2022

  # TODO
  - title: Assumed type arguments have no declared type.
    intro: |
      Fortran 2018 allows assumed type arguments that have no declared type, with syntax type(*). Such arguments can only be used in a small number of intrinsic functions, including SHAPE, SIZE, and RANK. Actual arguments can have intrinsic or derived types.
    file: ~
    file0: assumed_type.f90
    url: https://twitter.com/fortrantip/status/1496825853551992843
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2018 allows assumed type arguments that have no declared type, with syntax type(*). Such arguments can only be used in a small number of intrinsic functions, including SHAPE, SIZE, and RANK. Actual arguments can have intrinsic or derived types.<a href="https://t.co/mDry4PCOh9">pic.twitter.com/mDry4PCOh9</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1496825853551992843?ref_src=twsrc%5Etfw">February 24, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 25-Feb-2022

  # TODO
  - title: ERROR STOP vs. STOP.
    intro: |
      Fortran 2008 introduced the ERROR STOP statement, which can be used in PURE procedures, 
      unlike STOP. Error stop or stop can be followed by an integer or string that is printed. Error stop on one coarray image will terminate the entire program.
    file: ~
    file0: error_stop.f90
    url: https://twitter.com/fortrantip/status/1497181532146089985
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran 2008 introduced the ERROR STOP statement, which can be used in PURE procedures, <br>unlike STOP. Error stop or stop can be followed by an integer or string that is printed. Error stop on one coarray image will terminate the entire program.<a href="https://t.co/M1lajeSZvp">pic.twitter.com/M1lajeSZvp</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1497181532146089985?ref_src=twsrc%5Etfw">February 25, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 26-Feb-2022

  # TODO
  - title: Check that assumed-shape array arguments have consistent dimensions.
    intro: |
      Check that assumed-shape array arguments have consistent dimensions. Using the FINDLOC function of Fortran 2008 on a logical array of constraints can reduce the amount of boilerplate code needed:

      ierr = findloc([con1,con2,con3],value=.false.,dim=1)
    file: ~
    file0: error_handling.f90
    url: https://twitter.com/fortrantip/status/1497562564334694401
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Check that assumed-shape array arguments have consistent dimensions. Using the FINDLOC function of Fortran 2008 on a logical array of constraints can reduce the amount of boilerplate code needed:<br><br>ierr = findloc([con1,con2,con3],value=.false.,dim=1)<a href="https://t.co/aRUxpXWIEY">pic.twitter.com/aRUxpXWIEY</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1497562564334694401?ref_src=twsrc%5Etfw">February 26, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 27-Feb-2022

  # TODO
  - title: Errors in a procedure can be handled with an optional argument.
    intro: |
      Errors in a procedure can be handled by setting an error flag and returning or by stopping with an error message. A procedure with an optional error flag argument can handle errors in either way, depending on whether an error flag is passed.
    file: ~
    file0: optional_err.f90
    url: https://twitter.com/fortrantip/status/1497902611915284482
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Errors in a procedure can be handled by setting an error flag and returning or by stopping with an error message. A procedure with an optional error flag argument can handle errors in either way, depending on whether an error flag is passed.<a href="https://t.co/IMhQY8pLfw">pic.twitter.com/IMhQY8pLfw</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1497902611915284482?ref_src=twsrc%5Etfw">February 27, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 28-Feb-2022

  # TODO
  - title: Five free C C++ Fortran compiler families
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1498291406556876806
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/6R7rwViMRE">https://t.co/6R7rwViMRE</a><br>They are GNU, IntelOneAPI, LLVM, NVIDIA HPC, and IBM XL (for POWER CPUs).</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1498291406556876806?ref_src=twsrc%5Etfw">February 28, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 01-Mar-2022

  # TODO
  - title: BLOCK construct allows declarations after executable statements.
    intro: |
      The BLOCK construct of Fortran 2008 allows variables to be declared and exist only within the block. This permits variables to be declared closer to their use and deallocated earlier and can avoid name clashes. If the block is named, EXIT &lt;name&gt; leaves it
    file: ~
    file0: block.f90
    url: https://twitter.com/fortrantip/status/1498646417778548736
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The BLOCK construct of Fortran 2008 allows variables to be declared and exist only within the block. This permits variables to be declared closer to their use and deallocated earlier and can avoid name clashes. If the block is named, EXIT &lt;name&gt; leaves it <a href="https://t.co/4iAzqE52Qg">pic.twitter.com/4iAzqE52Qg</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1498646417778548736?ref_src=twsrc%5Etfw">March 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 02-Mar-2022

  # TODO
  - title: Internal procedures have access to variables from the host unless they are overridden by local variables.
    intro: |
      An internal procedure can declare variables with the same names as the enclosing procedure, which can declare variables with the same names as module variables. Within a scope a name refers to the local variable. Variables from the host are accessible.
    file: ~
    file0: scope.f90
    url: https://twitter.com/fortrantip/status/1499014126265372685
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An internal procedure can declare variables with the same names as the enclosing procedure, which can declare variables with the same names as module variables. Within a scope a name refers to the local variable. Variables from the host are accessible.<a href="https://t.co/9ics0WynEP">pic.twitter.com/9ics0WynEP</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1499014126265372685?ref_src=twsrc%5Etfw">March 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 03-Mar-2022

  # TODO
  - title: Pointer assignment and ASSOCIATE can create shallow copies.
    intro: |
      A pointer assignment or ASSOCIATE with the RHS a variable can create shallow copies where changes in one variable affect another. Normal assignment or ALLOCATE with SOURCE creates a deep copy.
      Created with @carbon_app
    file: ~
    file0: copy.f90
    url: https://twitter.com/fortrantip/status/1499368960151760896
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A pointer assignment or ASSOCIATE with the RHS a variable can create shallow copies where changes in one variable affect another. Normal assignment or ALLOCATE with SOURCE creates a deep copy.<br>Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/7FPHzH0uX2">pic.twitter.com/7FPHzH0uX2</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1499368960151760896?ref_src=twsrc%5Etfw">March 3, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 04-Mar-2022

  # TODO
  - title: ASSOCIATE is preferred over POINTER to create an alias because POINTER can inhibit optimization.
    intro: |
      Although ASSOCIATE of Fortran 2003 and POINTER of Fortran 90 can both create an alias for a derived type component or an array section, ASSOCIATE is now preferred since the use of POINTER can inhibit optimization.
    file: ~
    file0: associate_vs_pointer.f90
    url: https://twitter.com/fortrantip/status/1499720499181535247
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Although ASSOCIATE of Fortran 2003 and POINTER of Fortran 90 can both create an alias for a derived type component or an array section, ASSOCIATE is now preferred since the use of POINTER can inhibit optimization.<a href="https://t.co/n39lBNhTEz">pic.twitter.com/n39lBNhTEz</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1499720499181535247?ref_src=twsrc%5Etfw">March 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 05-Mar-2022

  # TODO
  - title: ASSOCIATE statement can set several independent variables.
    intro: |
      A single ASSOCIATE statement can create multiple variables, but they must be independent. If y depends on x you must first ASSOCIATE x and then ASSOCIATE y in a following statement. A loop with an ASSOCIATE must also have an END ASSOCIATE.
    file: ~
    file0: associate_many.f90
    url: https://twitter.com/fortrantip/status/1500087163668549636
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A single ASSOCIATE statement can create multiple variables, but they must be independent. If y depends on x you must first ASSOCIATE x and then ASSOCIATE y in a following statement. A loop with an ASSOCIATE must also have an END ASSOCIATE.<a href="https://t.co/aTf72Py2cg">pic.twitter.com/aTf72Py2cg</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1500087163668549636?ref_src=twsrc%5Etfw">March 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 06-Mar-2022

  # TODO
  - title: A variable ASSOCIATEd to an ALLOCATABLE variable is not ALLOCATABLE.
    intro: |
      In an ASSOCIATE statement the LHS is not ALLOCATABLE even if the RHS is. If the RHS is an allocatable array, it must already be ALLOCATED, and it should not be reallocated or deallocated within the ASSOCIATE block.
    file: ~
    file0: associate_alloc.f90
    url: https://twitter.com/fortrantip/status/1500448694734364675
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In an ASSOCIATE statement the LHS is not ALLOCATABLE even if the RHS is. If the RHS is an allocatable array, it must already be ALLOCATED, and it should not be reallocated or deallocated within the ASSOCIATE block.<a href="https://t.co/cOHvBuqK4X">pic.twitter.com/cOHvBuqK4X</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1500448694734364675?ref_src=twsrc%5Etfw">March 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Tips by topic
    intro: |
      Since the tip topics have jumped around, I have listed them by topic.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1500472144878313473
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Since the tip topics have jumped around, I have listed them by topic.<a href="https://t.co/rUZiffPR5o">https://t.co/rUZiffPR5o</a><br>To suggest a topic please raise an issue at GitHub or send a direct message.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1500472144878313473?ref_src=twsrc%5Etfw">March 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 07-Mar-2022

  # TODO
  - title: Bounds of associate-name for whole array or array section selector
    intro: |
      The left-hand side of an association (associate-name) has the same bounds as the right-hand side (selector) if it is a whole array but has lower bounds of 1 if the selector is an array section.
    file: ~
    file0: associate_bounds.f90
    url: https://twitter.com/fortrantip/status/1500813206356430848
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The left-hand side of an association (associate-name) has the same bounds as the right-hand side (selector) if it is a whole array but has lower bounds of 1 if the selector is an array section.<a href="https://t.co/uQzrh5I0iR">pic.twitter.com/uQzrh5I0iR</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1500813206356430848?ref_src=twsrc%5Etfw">March 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 08-Mar-2022

  # TODO
  - title: Pointer can remap array shape and bounds.
    intro: |
      A pointer can be used to map an array to an array of the same type and size but a different shape, rank, or bounds, for example

      real, target  :: y(6)
      real, pointer :: p(:,:)
      p(-1:1,1:2) =&gt; y ! map y(:) to 3x2 matrix with LB -1, 1
    file: ~
    file0: pointer_reshape.f90
    url: https://twitter.com/fortrantip/status/1501169574997377025
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A pointer can be used to map an array to an array of the same type and size but a different shape, rank, or bounds, for example<br><br>real, target  :: y(6)<br>real, pointer :: p(:,:)<br>p(-1:1,1:2) =&gt; y ! map y(:) to 3x2 matrix with LB -1, 1<a href="https://t.co/rZ72DjBWgH">pic.twitter.com/rZ72DjBWgH</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1501169574997377025?ref_src=twsrc%5Etfw">March 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 09-Mar-2022

  # TODO
  - title: Pointer should be initialized to null() to avoid undefined association status.
    intro: |
      Whether a pointer is initially ASSOCIATED is undefined, unless the pointer is initialized to null(), which makes it not associated. This is recommended. A pointer becomes associated by being allocated or by being given a target.
    file: ~
    file0: pointer_use.f90
    url: https://twitter.com/fortrantip/status/1501547568307728385
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Whether a pointer is initially ASSOCIATED is undefined, unless the pointer is initialized to null(), which makes it not associated. This is recommended. A pointer becomes associated by being allocated or by being given a target.<a href="https://t.co/D8eBKzMZ0i">pic.twitter.com/D8eBKzMZ0i</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1501547568307728385?ref_src=twsrc%5Etfw">March 9, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 10-Mar-2022

  # TODO
  - title: Use ALLOCATABLE arrays or ASSOCIATE instead of POINTER when possible.
    intro: |
      In Fortran 90, allocatable arrays could not be used as procedure arguments or derived type components. An old code may use pointers in these situations, where it is now safer and more convenient to use allocatable arrays. In other cases POINTER can be replaced by
      ASSOCIATE.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1501898993785319429
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In Fortran 90, allocatable arrays could not be used as procedure arguments or derived type components. An old code may use pointers in these situations, where it is now safer and more convenient to use allocatable arrays. In other cases POINTER can be replaced by<br>ASSOCIATE.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1501898993785319429?ref_src=twsrc%5Etfw">March 10, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 11-Mar-2022

  # TODO
  - title: Connect INPUT_UNIT and OUTPUT_UNIT to files to redirect standard input and output.
    intro: |
      Module ISO_FORTRAN_ENV has named constants INPUT_UNIT and OUTPUT_UNIT, usually 5 and 6. Connecting output_unit to a file sends the output of
      PRINT fmt, and WRITE (*,fmt) to that file. Connecting input_unit to a file causes READ (*,fmt) to access that file
    file: ~
    file0: output_unit.f90
    url: https://twitter.com/fortrantip/status/1502277940066893835
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Module ISO_FORTRAN_ENV has named constants INPUT_UNIT and OUTPUT_UNIT, usually 5 and 6. Connecting output_unit to a file sends the output of<br>PRINT fmt, and WRITE (*,fmt) to that file. Connecting input_unit to a file causes READ (*,fmt) to access that file<a href="https://t.co/2IdX5vwkfu">pic.twitter.com/2IdX5vwkfu</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1502277940066893835?ref_src=twsrc%5Etfw">March 11, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 12-Mar-2022

  # TODO
  - title: Unit n is connected to fort.n by default for most compilers.
    intro: |
      For a positive integer n other than 5 or 6 that has not been connected to a file with OPEN,

      write (n,*) "hello"

      will write to a file with n in the name, such as fort.10 for n = 10, with details up to the compiler.
    file: ~
    file0: implicitly_connected.f90
    url: https://twitter.com/fortrantip/status/1502625494499536904
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For a positive integer n other than 5 or 6 that has not been connected to a file with OPEN,<br><br>write (n,*) &quot;hello&quot;<br><br>will write to a file with n in the name, such as fort.10 for n = 10, with details up to the compiler.<a href="https://t.co/bv8FnEq0UZ">pic.twitter.com/bv8FnEq0UZ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1502625494499536904?ref_src=twsrc%5Etfw">March 12, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 13-Mar-2022

  # TODO
  - title: Write to many files by creating file names with internal write.
    intro: |
      To portably create many files named by integers with specified prefix and suffix you can loop over the integers and in the loop body use an internal write to create the file name, connect the file to a unit, write to it, and then close it.
    file: ~
    file0: write_many_files.f90
    url: https://twitter.com/fortrantip/status/1503015109354045442
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To portably create many files named by integers with specified prefix and suffix you can loop over the integers and in the loop body use an internal write to create the file name, connect the file to a unit, write to it, and then close it.<a href="https://t.co/M7UFaRglkv">pic.twitter.com/M7UFaRglkv</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1503015109354045442?ref_src=twsrc%5Etfw">March 13, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 14-Mar-2022

  # TODO
  - title: Number of files open simultaneously is limited, so they should be closed when possible.
    intro: |
      The number of files that can be connected simultaneously differs by compiler and operating system, so files that will no longer be used should be closed, especially when opened in a loop. On Unix ulimit -n gives the maximum # of open file descriptors.
    file: ~
    file0: open_units_limit.f90
    url: https://twitter.com/fortrantip/status/1503339726534852615
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The number of files that can be connected simultaneously differs by compiler and operating system, so files that will no longer be used should be closed, especially when opened in a loop. On Unix ulimit -n gives the maximum # of open file descriptors.<a href="https://t.co/sSJe11cw8X">pic.twitter.com/sSJe11cw8X</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1503339726534852615?ref_src=twsrc%5Etfw">March 14, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 15-Mar-2022

  # TODO
  - title: Use NEWUNIT in OPEN to get an unused unit number.
    intro: |
      open (newunit=iu,...)

      is a Fortran 2008 feature that finds an unused unit number less than -1. By doing this instead of hard coding a unit number, you avoid inadvertently using a unit number that is already connected.
    file: ~
    file0: newunit.f90
    url: https://twitter.com/fortrantip/status/1503700530496946177
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">open (newunit=iu,...)<br><br>is a Fortran 2008 feature that finds an unused unit number less than -1. By doing this instead of hard coding a unit number, you avoid inadvertently using a unit number that is already connected.<a href="https://t.co/197XS6ABbM">pic.twitter.com/197XS6ABbM</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1503700530496946177?ref_src=twsrc%5Etfw">March 15, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 16-Mar-2022

  # TODO
  - title: Use INQUIRE to get unit and file properties.
    intro: |
      The INQUIRE statement can tell if a unit has been opened, if a file exists, a file's size, whether it is open for reading or writing, formatted or not, its form of access, and other properties. Common uses of INQUIRE can be wrapped as functions as shown.
    file: ~
    file0: inquire.f90
    url: https://twitter.com/fortrantip/status/1504067234326528000
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The INQUIRE statement can tell if a unit has been opened, if a file exists, a file&#39;s size, whether it is open for reading or writing, formatted or not, its form of access, and other properties. Common uses of INQUIRE can be wrapped as functions as shown.<a href="https://t.co/4ksASPJnLS">pic.twitter.com/4ksASPJnLS</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1504067234326528000?ref_src=twsrc%5Etfw">March 16, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 17-Mar-2022

  # TODO
  - title: How to append to a file or delete it
    intro: |
      In an OPEN statement with ACTION="write", use POSITION="append" to append data to a file rather than overwriting it. To delete a file that is connected to a unit, CLOSE that unit with STATUS="delete".
    file: ~
    file0: write_append.f90
    url: https://twitter.com/fortrantip/status/1504422788517576704
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In an OPEN statement with ACTION=&quot;write&quot;, use POSITION=&quot;append&quot; to append data to a file rather than overwriting it. To delete a file that is connected to a unit, CLOSE that unit with STATUS=&quot;delete&quot;.<a href="https://t.co/WN3uo3agpf">pic.twitter.com/WN3uo3agpf</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1504422788517576704?ref_src=twsrc%5Etfw">March 17, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-Mar-2022

  # TODO
  - title: DIRECT access file allows access to arbitrary record without looping over the previous records.
    intro: |
      A DIRECT access data file lets you read or write an arbitrary record without looping over the previous records, as needed with the usual SEQUENTIAL access. The record length RECL is given in the OPEN statement, and READ or WRITE need a record number REC.
    file: ~
    file0: direct_access.f90
    url: https://twitter.com/fortrantip/status/1504793375765155840
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A DIRECT access data file lets you read or write an arbitrary record without looping over the previous records, as needed with the usual SEQUENTIAL access. The record length RECL is given in the OPEN statement, and READ or WRITE need a record number REC.<a href="https://t.co/FRvhhG3che">pic.twitter.com/FRvhhG3che</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1504793375765155840?ref_src=twsrc%5Etfw">March 18, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-Mar-2022

  # TODO
  - title: Specific array elements can read or written to unformatted stream file by specifying the POS.
    intro: |
      Unformatted stream I/O is fast for large data sets. By specifying the POSition in the READ or WRITE of an unformatted stream file, you can read or write an arbitrary array element in the file without looping over previous elements.
    file: ~
    file0: stream_pos_dt.f90
    url: https://twitter.com/fortrantip/status/1505150360851210241
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Unformatted stream I/O is fast for large data sets. By specifying the POSition in the READ or WRITE of an unformatted stream file, you can read or write an arbitrary array element in the file without looping over previous elements.<a href="https://t.co/INZyxK0foW">pic.twitter.com/INZyxK0foW</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1505150360851210241?ref_src=twsrc%5Etfw">March 19, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Stream input/output article by Clive Page
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1505153106228690946
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/QMS2EyFcPF">https://t.co/QMS2EyFcPF</a><br>The Fortran Wiki has an article on stream input/output by Clive Page.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1505153106228690946?ref_src=twsrc%5Etfw">March 19, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-Mar-2022

  # TODO
  - title: Slash / terminates a record.
    intro: |
      A / in a format creates a new record, so

      print "('c'/'d')"

      prints 'c' and 'd' on successive lines, as does

      print "(a)","c" // new_line("") // "d"

      A list-directed READ is terminated by a / in input and may surprise for a file with / characters.
    file: ~
    file0: slash.f90
    url: https://twitter.com/fortrantip/status/1505555510262697987
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A / in a format creates a new record, so<br><br>print &quot;(&#39;c&#39;/&#39;d&#39;)&quot;<br><br>prints &#39;c&#39; and &#39;d&#39; on successive lines, as does<br><br>print &quot;(a)&quot;,&quot;c&quot; // new_line(&quot;&quot;) // &quot;d&quot;<br><br>A list-directed READ is terminated by a / in input and may surprise for a file with / characters.<a href="https://t.co/e8hvGptp4z">pic.twitter.com/e8hvGptp4z</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1505555510262697987?ref_src=twsrc%5Etfw">March 20, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 21-Mar-2022

  # TODO
  - title: Use REWIND and BACKSPACE to change file position.
    intro: |
      REWIND (unit=u) positions the file at the beginning so it can be reread or rewritten. A WRITE deletes lines after the position. BACKSPACE moves the position back one line. It can be used to print an informative error message when a READ fails.
    file: ~
    file0: rewind.f90
    url: https://twitter.com/fortrantip/status/1505877382716170245
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">REWIND (unit=u) positions the file at the beginning so it can be reread or rewritten. A WRITE deletes lines after the position. BACKSPACE moves the position back one line. It can be used to print an informative error message when a READ fails.<a href="https://t.co/5uCuyaxNY5">pic.twitter.com/5uCuyaxNY5</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1505877382716170245?ref_src=twsrc%5Etfw">March 21, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 22-Mar-2022

  # TODO
  - title: EXIT can be used to leave a named outer loop.
    intro: |
      Loops can be labeled with syntax

      name1: do i=1,n
         name2: do j=1,n
            ...
         end do name2
      end do name1

      EXIT leaves the inner loop. EXIT &lt;name&gt; can be used to leave an outer loop. A loop label also clarifies what loop is terminated by END DO.
    file: ~
    file0: loop_label.f90
    url: https://twitter.com/fortrantip/status/1506235487782113282
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Loops can be labeled with syntax<br><br>name1: do i=1,n<br>   name2: do j=1,n<br>      ...<br>   end do name2<br>end do name1<br><br>EXIT leaves the inner loop. EXIT &lt;name&gt; can be used to leave an outer loop. A loop label also clarifies what loop is terminated by END DO.<a href="https://t.co/leKjbkwyOm">pic.twitter.com/leKjbkwyOm</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1506235487782113282?ref_src=twsrc%5Etfw">March 22, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 23-Mar-2022

  # TODO
  - title: CYCLE skips the remaining statements in a loop.
    intro: |
      CYCLE skips the remaining statements in a loop, continuing to the next iteration. CYCLE &lt;name&gt; can skip the remaining statements of a named outer loop.
    file: ~
    file0: cycle.f90
    url: https://twitter.com/fortrantip/status/1506603320361857026
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">CYCLE skips the remaining statements in a loop, continuing to the next iteration. CYCLE &lt;name&gt; can skip the remaining statements of a named outer loop.<a href="https://t.co/plMA9GrWov">pic.twitter.com/plMA9GrWov</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1506603320361857026?ref_src=twsrc%5Etfw">March 23, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 24-Mar-2022

  # TODO
  - title: Changing a loop index within a loop is invalid.
    intro: |
      Changing the loop index within a loop is not allowed, but a compiler may not catch it if it happens in another procedure. It is safer to pass a loop index only to procedures where it is an INTENT(IN) argument.
    file: ~
    file0: loop_index.f90
    url: https://twitter.com/fortrantip/status/1506976258411872268
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Changing the loop index within a loop is not allowed, but a compiler may not catch it if it happens in another procedure. It is safer to pass a loop index only to procedures where it is an INTENT(IN) argument.<a href="https://t.co/RaDHvxsvrv">pic.twitter.com/RaDHvxsvrv</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1506976258411872268?ref_src=twsrc%5Etfw">March 24, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 25-Mar-2022

  # TODO
  - title: Number of iterations in a loop is determined at the beginning.
    intro: |
      The number of iterations in a loop is determined at the beginning of the loop and is unaffected by changing the loop bound variables within the loop, but doing so may confuse the reader.
    file: ~
    file0: loop_bound.f90
    url: https://twitter.com/fortrantip/status/1507323239151906819
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The number of iterations in a loop is determined at the beginning of the loop and is unaffected by changing the loop bound variables within the loop, but doing so may confuse the reader.<a href="https://t.co/rH6kehDFIJ">pic.twitter.com/rH6kehDFIJ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1507323239151906819?ref_src=twsrc%5Etfw">March 25, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 26-Mar-2022

  # TODO
  - title: Beware of a loop to huge(i), since huge(i)+1 is out of range.
    intro: |
      To loop from 1 to a large number, with the loop terminated by an EXIT, write

      do i=1,huge(i)-1
         ! code
         if (cond) exit
      end do

      It is invalid for the upper bound to be huge(i), since i is set to huge(i)+1 upon exit, which is out of range.
    file: ~
    file0: huge_loop.f90
    url: https://twitter.com/fortrantip/status/1507669898486501381
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To loop from 1 to a large number, with the loop terminated by an EXIT, write<br><br>do i=1,huge(i)-1<br>   ! code<br>   if (cond) exit<br>end do<br><br>It is invalid for the upper bound to be huge(i), since i is set to huge(i)+1 upon exit, which is out of range.<a href="https://t.co/bv6j43P7d8">pic.twitter.com/bv6j43P7d8</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1507669898486501381?ref_src=twsrc%5Etfw">March 26, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Invalid loop bounds were discussed at Fortran Discourse.
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1507673746965946368
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/JHQ9gv9Wat">https://t.co/JHQ9gv9Wat</a><br>Invalid loop bounds were discussed at Fortran Discourse.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1507673746965946368?ref_src=twsrc%5Etfw">March 26, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 27-Mar-2022

  # TODO
  - title: DO WHILE loop iterates as long as condition at beginning is met.
    intro: |
      A DO WHILE loop iterates as long as the condition at the beginning of the loop is met. The syntax is

      do while (condition)
         ...
      end do

      An infinite do loop allows the test for exiting to be made anywhere in the loop and is more flexible.
    file: ~
    file0: do_while.f90
    url: https://twitter.com/fortrantip/status/1508040660124848129
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A DO WHILE loop iterates as long as the condition at the beginning of the loop is met. The syntax is<br><br>do while (condition)<br>   ...<br>end do<br><br>An infinite do loop allows the test for exiting to be made anywhere in the loop and is more flexible.<a href="https://t.co/FChl184asF">pic.twitter.com/FChl184asF</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1508040660124848129?ref_src=twsrc%5Etfw">March 27, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 28-Mar-2022

  # TODO
  - title: print*,char(7) causes the program to beep.
    intro: |
      In ASCII and Unicode the character with the value 7 is BEL, so

      print*,char(7)

      will cause the program to beep, which can be used to signal completion.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1508401513445605379
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In ASCII and Unicode the character with the value 7 is BEL, so<br><br>print*,char(7)<br><br>will cause the program to beep, which can be used to signal completion.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1508401513445605379?ref_src=twsrc%5Etfw">March 28, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 29-Mar-2022

  # TODO
  - title: Use an implied do loop with TRIM to print an array of character variables without trailing blanks.
    intro: |
      Since TRIM is not elemental, use an implied do loop with TRIM to print an array of character variables without trailing blanks: 

      print "(*(a,:,','))",(trim(s(i)),i=1,size(s))

      A function can join trimmed strings as shown.
    file: ~
    file0: trim_loop.f90
    url: https://twitter.com/fortrantip/status/1508769980313124870
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Since TRIM is not elemental, use an implied do loop with TRIM to print an array of character variables without trailing blanks: <br><br>print &quot;(*(a,:,&#39;,&#39;))&quot;,(trim(s(i)),i=1,size(s))<br><br>A function can join trimmed strings as shown. <a href="https://t.co/u6GPRscyBm">pic.twitter.com/u6GPRscyBm</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1508769980313124870?ref_src=twsrc%5Etfw">March 29, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 30-Mar-2022

  # TODO
  - title: Error in READ statement causes all variables to become undefined.
    intro: |
      If there is an error in a READ statement, all read items become undefined, although most compilers will update only the variables that can be read. The safe approach is to read temporary variables and set variables to them when READ is successful.
    file: ~
    file0: read_err.f90
    url: https://twitter.com/fortrantip/status/1509144120404676611
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If there is an error in a READ statement, all read items become undefined, although most compilers will update only the variables that can be read. The safe approach is to read temporary variables and set variables to them when READ is successful. <a href="https://t.co/viXblw7sEp">pic.twitter.com/viXblw7sEp</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1509144120404676611?ref_src=twsrc%5Etfw">March 30, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 31-Mar-2022

  # TODO
  - title: Use the "(a)" format to read a line of a file into a string.
    intro: |
      character (len=100) :: s
      read (iunit,"(a)") s

      will read the first 100 characters of a line into s, padding with blanks if necessary.

      read (iunit,*) s

      will read the first "word" of the line, where words are separated by blanks or commas.
    file: ~
    file0: read_line.f90
    url: https://twitter.com/fortrantip/status/1509493654678876166
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">character (len=100) :: s<br>read (iunit,&quot;(a)&quot;) s<br><br>will read the first 100 characters of a line into s, padding with blanks if necessary.<br><br>read (iunit,*) s<br><br>will read the first &quot;word&quot; of the line, where words are separated by blanks or commas.<a href="https://t.co/ecBC7hKu6v">pic.twitter.com/ecBC7hKu6v</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1509493654678876166?ref_src=twsrc%5Etfw">March 31, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: MOOC on "Defensive programming and debugging"
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1509557710810980358
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/oIbB4xhpEX">https://t.co/oIbB4xhpEX</a><br>A MOOC on &quot;Defensive programming and debugging&quot; in C, C++, and Fortran is starting, with a companion web site. A previous MOOC from PRACE was &quot;Fortran for Scientific Computing&quot;.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1509557710810980358?ref_src=twsrc%5Etfw">March 31, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 01-Apr-2022

  # TODO
  - title: List-directed READ will use several lines if necessary.
    intro: |
      A list-directed read will read data from as many lines as needed for the items, so a malformed data file may go undetected. To read items from a single line, first read the line with the "(a)" format into a string and then read items from the string.
    file: ~
    file0: list_directed.f90
    url: https://twitter.com/fortrantip/status/1509858203227545602
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A list-directed read will read data from as many lines as needed for the items, so a malformed data file may go undetected. To read items from a single line, first read the line with the &quot;(a)&quot; format into a string and then read items from the string.<a href="https://t.co/WJh6E6v0Mh">pic.twitter.com/WJh6E6v0Mh</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1509858203227545602?ref_src=twsrc%5Etfw">April 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 02-Apr-2022

  # TODO
  - title: Use an implied do loop with a dummy variable to skip fields when reading a file.
    intro: |
      To skip reading N fields of a space- or comma-delimited file, a dummy variable can be read N times in an implied do loop before the actual  data is read. A READ with no items skips a line in a file.
    file: ~
    file0: skip_columns.f90
    url: https://twitter.com/fortrantip/status/1510212760201830401
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To skip reading N fields of a space- or comma-delimited file, a dummy variable can be read N times in an implied do loop before the actual  data is read. A READ with no items skips a line in a file.<a href="https://t.co/KGhVGgiZrW">pic.twitter.com/KGhVGgiZrW</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1510212760201830401?ref_src=twsrc%5Etfw">April 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 03-Apr-2022

  # TODO
  - title: Because recursive I/O is prohibited, a function should use ERROR STOP msg instead of PRINT statements for error messages.
    intro: |
      Because recursive I/O is prohibited, a function should not have PRINT or WRITE(*,fmt) statements for error messages, since the behavior of

      print*,f(x)

      is then undefined. ERROR STOP &lt;msg&gt; is an alternative. Internal write can be useful in a function.
    file: ~
    file0: recursive_io.f90
    url: https://twitter.com/fortrantip/status/1510585396467535879
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Because recursive I/O is prohibited, a function should not have PRINT or WRITE(*,fmt) statements for error messages, since the behavior of<br><br>print*,f(x)<br><br>is then undefined. ERROR STOP &lt;msg&gt; is an alternative. Internal write can be useful in a function.<a href="https://t.co/wjAoag2Hgl">pic.twitter.com/wjAoag2Hgl</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1510585396467535879?ref_src=twsrc%5Etfw">April 3, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 04-Apr-2022

  # TODO
  - title: Read a file into a string with unformatted stream.
    intro: |
      An entire file can be read into a string by 

      (1) using INQUIRE to get the file size
      (2) allocating a string to this size
      (3) reading the string using unformatted stream 

      The string can then be broken into lines by searching for newline characters.
    file: ~
    file0: file_to_string.f90
    url: https://twitter.com/fortrantip/status/1510940360582782976
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An entire file can be read into a string by <br><br>(1) using INQUIRE to get the file size<br>(2) allocating a string to this size<br>(3) reading the string using unformatted stream <br><br>The string can then be broken into lines by searching for newline characters.<a href="https://t.co/khKAhk83HM">pic.twitter.com/khKAhk83HM</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1510940360582782976?ref_src=twsrc%5Etfw">April 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 05-Apr-2022

  # TODO
  - title: Scratch files are unnamed temporary files for I/O.
    intro: |
      A scratch file is an unnamed temporary file intended to exist only during a program run, which gives the system flexibility in its location. It is deleted when closed or when the program terminates. The Fortran Wiki has an article on scratch files.
    file: ~
    file0: scratch.f90
    url: https://twitter.com/fortrantip/status/1511318331659325445
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A scratch file is an unnamed temporary file intended to exist only during a program run, which gives the system flexibility in its location. It is deleted when closed or when the program terminates. The Fortran Wiki has an article on scratch files.<a href="https://t.co/mQqhUemPkx">pic.twitter.com/mQqhUemPkx</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1511318331659325445?ref_src=twsrc%5Etfw">April 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 06-Apr-2022

  # TODO
  - title: Place IMPLICIT NONE before CONTAINS in a module.
    intro: |
      Place IMPLICIT NONE after USE statements but before the CONTAINS statement in a module. Then IMPLICIT NONE in CONTAINed module procedures is legal but redundant.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1511683238212816903
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Place IMPLICIT NONE after USE statements but before the CONTAINS statement in a module. Then IMPLICIT NONE in CONTAINed module procedures is legal but redundant.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1511683238212816903?ref_src=twsrc%5Etfw">April 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 07-Apr-2022

  # TODO
  - title: ALLOCATE with SOURCE or MOLD to set values or SHAPE.
    intro: |
      Some forms of ALLOCATE are

      allocate (y(2)) ! y undefined
      allocate (y(2),source=0.0) ! fill with zeros
      allocate (y(2),source=[3.0,4.0]) ! fill with [3.0,4.0]
      allocate (y,mold=x) ! get shape from x
      allocate (y,source=x) ! get shape and values from x
    file: ~
    file0: alloc_source_mold.f90
    url: https://twitter.com/fortrantip/status/1512018397734838274
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Some forms of ALLOCATE are<br><br>allocate (y(2)) ! y undefined<br>allocate (y(2),source=0.0) ! fill with zeros<br>allocate (y(2),source=[3.0,4.0]) ! fill with [3.0,4.0]<br>allocate (y,mold=x) ! get shape from x<br>allocate (y,source=x) ! get shape and values from x <a href="https://t.co/n4fKcZUdXA">pic.twitter.com/n4fKcZUdXA</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1512018397734838274?ref_src=twsrc%5Etfw">April 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: ASSOCIATE to an array-valued expression allocates an array.
    intro: |
      Also possible is allocation on assignment 

      real, allocatable :: x(:)
      x = [1.0,2.0] ! works even if x is allocated

      or ASSOCIATE with an array-valued expression

      ASSOCIATE (x =&gt; [1.0,2.0])
      ! x is fixed within ASSOCIATE block
      ...
      END ASSOCIATE

      as shown in the last code.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1512020145853673478
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Also possible is allocation on assignment <br><br>real, allocatable :: x(:)<br>x = [1.0,2.0] ! works even if x is allocated<br><br>or ASSOCIATE with an array-valued expression<br><br>ASSOCIATE (x =&gt; [1.0,2.0])<br>! x is fixed within ASSOCIATE block<br>...<br>END ASSOCIATE<br><br>as shown in the last code.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1512020145853673478?ref_src=twsrc%5Etfw">April 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 08-Apr-2022

  # TODO
  - title: ALLOCATE has an optional ERRMSG specifier.
    intro: |
      The ERRMSG specifier of ALLOCATE gives an error message when an ALLOCATE fails. Two common reasons are an already allocated variable or insufficient memory. ALLOCATE with ERRMSG should also have the
      STAT specifier to avoid program termination upon error.
    file: ~
    file0: alloc_errmsg.f90
    url: https://twitter.com/fortrantip/status/1512395017473736704
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The ERRMSG specifier of ALLOCATE gives an error message when an ALLOCATE fails. Two common reasons are an already allocated variable or insufficient memory. ALLOCATE with ERRMSG should also have the<br>STAT specifier to avoid program termination upon error.<a href="https://t.co/dGRmUGaVe0">pic.twitter.com/dGRmUGaVe0</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1512395017473736704?ref_src=twsrc%5Etfw">April 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 09-Apr-2022

  # TODO
  - title: If unsure, test whether a variable is ALLOCATED before using DEALLOCATE.
    intro: |
      Since (ALLOCATE / DEALLOCATE) is valid only when a variable is (not allocated / allocated), when the allocation status of a variable is unclear from reading the code you can write

      if (allocated(x)) deallocate(x)
      allocate (x(n))
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1512757635291963395
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Since (ALLOCATE / DEALLOCATE) is valid only when a variable is (not allocated / allocated), when the allocation status of a variable is unclear from reading the code you can write<br><br>if (allocated(x)) deallocate(x)<br>allocate (x(n))</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1512757635291963395?ref_src=twsrc%5Etfw">April 9, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 10-Apr-2022

  # TODO
  - title: Use MOVE_ALLOC to resize an array.
    intro: |
      CALL MOVE_ALLOC(FROM,TO) copies FROM to TO and then deallocates FROM. It can be used to expand array x(:) with

      n = size(x)
      allocate (y(n+size(new)))
      y(:n) = x
      y(n+1:) = new
      call move_alloc(from=y,to=x)

      This may be faster than

      x = [x,new]
    file: ~
    file0: move_alloc.f90
    url: https://twitter.com/fortrantip/status/1513111554107006979
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">CALL MOVE_ALLOC(FROM,TO) copies FROM to TO and then deallocates FROM. It can be used to expand array x(:) with<br><br>n = size(x)<br>allocate (y(n+size(new)))<br>y(:n) = x<br>y(n+1:) = new<br>call move_alloc(from=y,to=x)<br><br>This may be faster than<br><br>x = [x,new]<a href="https://t.co/ljSNwAxZVR">pic.twitter.com/ljSNwAxZVR</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1513111554107006979?ref_src=twsrc%5Etfw">April 10, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: MOVE_ALLOC may be faster than RESHAPE or allocation on asignment to resize an array.
    intro: |
      Another way to grow an array is

      x = reshape(x,[size(x)+size(new)],pad=new)

      The code compares the speeds of move_alloc, reshape, and allocation on assignment in growing an array. Move_alloc was fastest for gfortran, but this is platform-dependent.
    file: ~
    file0: move_alloc_bench.f90
    url: https://twitter.com/fortrantip/status/1513125862916382720
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Another way to grow an array is<br><br>x = reshape(x,[size(x)+size(new)],pad=new)<br><br>The code compares the speeds of move_alloc, reshape, and allocation on assignment in growing an array. Move_alloc was fastest for gfortran, but this is platform-dependent.<a href="https://t.co/LMVRYZXBnt">pic.twitter.com/LMVRYZXBnt</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1513125862916382720?ref_src=twsrc%5Etfw">April 10, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 11-Apr-2022

  # TODO
  - title: Deallocating a derived type deallocates its allocatable components.
    intro: |
      Deallocating a derived type deallocates its allocatable components but not its pointer components, which can be deallocated manually before the derived type is. An INTENT(OUT) derived type dummy argument has its allocatable components deallocated.
    file: ~
    file0: alloc_dt.f90
    url: https://twitter.com/fortrantip/status/1513501493382496259
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Deallocating a derived type deallocates its allocatable components but not its pointer components, which can be deallocated manually before the derived type is. An INTENT(OUT) derived type dummy argument has its allocatable components deallocated. <a href="https://t.co/072EgfRFe1">pic.twitter.com/072EgfRFe1</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1513501493382496259?ref_src=twsrc%5Etfw">April 11, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 12-Apr-2022

  # TODO
  - title: Links to tutorials on parameterized derived types (PDT).
    intro: |
      The components of a derived type should allocated in a single place so that they are dimensioned consistently. The parameterized derived type of F2003 facilitates this. Tutorials by Iain Barrass and Mark Leair are at
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1513863460706308096
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The components of a derived type should allocated in a single place so that they are dimensioned consistently. The parameterized derived type of F2003 facilitates this. Tutorials by Iain Barrass and Mark Leair are at <a href="https://t.co/rcOPdyjWzO">https://t.co/rcOPdyjWzO</a> and <a href="https://t.co/FzrwQhYc4q">https://t.co/FzrwQhYc4q</a> .</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1513863460706308096?ref_src=twsrc%5Etfw">April 12, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 13-Apr-2022

  # TODO
  - title: PDT can have array dimension, KIND, and character LEN parameters.
    intro: |
      A parameterized derived type (PDT) can have array dimensions, kinds,  and character LENs as parameters, with default values allowed:

      type :: matrix(n1,n2,wp)
        integer, len  :: n1, n2
        integer, kind :: wp = kind(1d0)
        real(kind=wp) :: x(n1,n2)
      end type
    file: ~
    file0: pdt_matrix.f90
    url: https://twitter.com/fortrantip/status/1514220328846831625
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A parameterized derived type (PDT) can have array dimensions, kinds,  and character LENs as parameters, with default values allowed:<br><br>type :: matrix(n1,n2,wp)<br>  integer, len  :: n1, n2<br>  integer, kind :: wp = kind(1d0)<br>  real(kind=wp) :: x(n1,n2)<br>end type<a href="https://t.co/Mxxa8Tof2V">pic.twitter.com/Mxxa8Tof2V</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1514220328846831625?ref_src=twsrc%5Etfw">April 13, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: PDT can have fixed parameters at compile time or be ALLOCATABLE.
    intro: |
      A PDT can have fixed parameters at compile time or be ALLOCATABLE.

      type(matrix(n1=3,n2=6,wp=kind(1d0))) :: a
      type(matrix(:,:)), allocatable :: b
      allocate (matrix(3,6) :: b)

      The type parameters are accessible, read-only, as

      a%n1, a%n2, a%wp
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1514220538071244804
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A PDT can have fixed parameters at compile time or be ALLOCATABLE.<br><br>type(matrix(n1=3,n2=6,wp=kind(1d0))) :: a<br>type(matrix(:,:)), allocatable :: b<br>allocate (matrix(3,6) :: b)<br><br>The type parameters are accessible, read-only, as<br><br>a%n1, a%n2, a%wp</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1514220538071244804?ref_src=twsrc%5Etfw">April 13, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 14-Apr-2022

  # TODO
  - title: Serialize a derived type using unformatted stream I/O.
    intro: |
      A derived type with allocatable components can be saved efficiently (serialized) by writing its dimensions and components using unformatted stream I/O. Later the dimensions and components (after allocation) can be read from the same file using stream I/O.
    file: ~
    file0: dt_stream.f90
    url: https://twitter.com/fortrantip/status/1514587088393494528
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A derived type with allocatable components can be saved efficiently (serialized) by writing its dimensions and components using unformatted stream I/O. Later the dimensions and components (after allocation) can be read from the same file using stream I/O.<a href="https://t.co/ht7rp2wy06">pic.twitter.com/ht7rp2wy06</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1514587088393494528?ref_src=twsrc%5Etfw">April 14, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 15-Apr-2022

  # TODO
  - title: Derived type array sections are allowed before or after the % component selector, but not in both places.
    intro: |
      For an array of derived types that have array components, you can refer to an array section at either level, but both array sections cannot have rank &gt; 0. The array sections

      t(1:n)%c(1)
      t(1)%c(1:2)

      are valid for array component c(:) but not

      t(1:n)%c
    file: ~
    file0: derived_type_section.f90
    url: https://twitter.com/fortrantip/status/1514939755892510727
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For an array of derived types that have array components, you can refer to an array section at either level, but both array sections cannot have rank &gt; 0. The array sections<br><br>t(1:n)%c(1)<br>t(1)%c(1:2)<br><br>are valid for array component c(:) but not<br><br>t(1:n)%c<a href="https://t.co/79rumEeJGI">pic.twitter.com/79rumEeJGI</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1514939755892510727?ref_src=twsrc%5Etfw">April 15, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 16-Apr-2022

  # TODO
  - title: Implied do loop can access arbitrary derived type array sections.
    intro: |
      An implied do loop can be used to access a derived type array section at more than one level.

      t(1:n)%c

      is invalid for array component c but

      [(t(i)%c,i=1,n)]

      or the transpose

      [((t(i)%c(j),i=1,size(t)),j=1,size_c)]

      are allowed expressions.
    file: ~
    file0: derived_type_implied_do.f90
    url: https://twitter.com/fortrantip/status/1515301634280148995
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An implied do loop can be used to access a derived type array section at more than one level.<br><br>t(1:n)%c<br><br>is invalid for array component c but<br><br>[(t(i)%c,i=1,n)]<br><br>or the transpose<br><br>[((t(i)%c(j),i=1,size(t)),j=1,size_c)]<br><br>are allowed expressions.<a href="https://t.co/GTtfS8cOCL">pic.twitter.com/GTtfS8cOCL</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1515301634280148995?ref_src=twsrc%5Etfw">April 16, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 17-Apr-2022

  # TODO
  - title: Fortran codes are listed by topic at the fortran-lang package index and Fortran Code on GitHub
    intro: |
      Many open-source Fortran codes are listed by topic at
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1515656659292598277
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Many open-source Fortran codes are listed by topic at<a href="https://t.co/JdtNnNmn1h">https://t.co/JdtNnNmn1h</a> and<a href="https://t.co/bZmof1LhWr">https://t.co/bZmof1LhWr</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1515656659292598277?ref_src=twsrc%5Etfw">April 17, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-Apr-2022

  # TODO
  - title: Use PACK to select records from an array of derived types.
    intro: |
      With an array of derived types, you can use PACK with a MASK on type components to select records, for example

      type :: t
         integer year, month, day
         real x
      end type t

      type(t) :: d(1000)
      print*,pack(d, d%month==3) ! data for March
      @carbon_app
    file: ~
    file0: query.f90
    url: https://twitter.com/fortrantip/status/1516024155698872329
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">With an array of derived types, you can use PACK with a MASK on type components to select records, for example<br><br>type :: t<br>   integer year, month, day<br>   real x<br>end type t<br><br>type(t) :: d(1000)<br>print*,pack(d, d%month==3) ! data for March<a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/S1QHRU5ft6">pic.twitter.com/S1QHRU5ft6</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1516024155698872329?ref_src=twsrc%5Etfw">April 18, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-Apr-2022

  # TODO
  - title: TRANSFER can be used to store one type in another type.
    intro: |
      The TRANSFER function interprets the bits of one type as another type. One use is to copy data from a derived type to an array or the reverse. An int64 can be stored in a real64 with full precision until it is TRANSFERred back, as can a character(len=8).
    file: ~
    file0: transfer.f90
    url: https://twitter.com/fortrantip/status/1516389389189984265
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The TRANSFER function interprets the bits of one type as another type. One use is to copy data from a derived type to an array or the reverse. An int64 can be stored in a real64 with full precision until it is TRANSFERred back, as can a character(len=8).<a href="https://t.co/dk7WjMWWuD">pic.twitter.com/dk7WjMWWuD</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1516389389189984265?ref_src=twsrc%5Etfw">April 19, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-Apr-2022

  # TODO
  - title: NOT, IAND, IOR, and IEOR perform logical operations on the bit representations of integers.
    intro: |
      BTEST(i,pos) gives the value of the bit in position pos of integer i, counting from 0 on the right. An N-bit integer can be used to store integers of a smaller BIT_SIZE or N booleans. Intrinsic functions for logical operations are NOT, IAND, IOR, and IEOR.
    file: ~
    file0: bit_func.f90
    url: https://twitter.com/fortrantip/status/1516749872019431432
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">BTEST(i,pos) gives the value of the bit in position pos of integer i, counting from 0 on the right. An N-bit integer can be used to store integers of a smaller BIT_SIZE or N booleans. Intrinsic functions for logical operations are NOT, IAND, IOR, and IEOR.<a href="https://t.co/V9e8Xlgy7Z">pic.twitter.com/V9e8Xlgy7Z</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1516749872019431432?ref_src=twsrc%5Etfw">April 20, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 21-Apr-2022

  # TODO
  - title: Create an executable in one step by compiling all source files or by compiling source files with -c and linking the object files.
    intro: |
      A program containing a module and main program is compiled with g95 as

      g95 m.f90 main.f90

      or with separate compilation

      # create m.o and main.o with the -c option
      g95 -c m.f90
      g95 -c main.f90
      # link objects to create exec
      g95 -o exec m.o main.f90

      Other compilers are similar.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1517106070614941697
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A program containing a module and main program is compiled with g95 as<br><br>g95 m.f90 main.f90<br><br>or with separate compilation<br><br># create m.o and main.o with the -c option<br>g95 -c m.f90<br>g95 -c main.f90<br># link objects to create exec<br>g95 -o exec m.o main.f90<br><br>Other compilers are similar.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1517106070614941697?ref_src=twsrc%5Etfw">April 21, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Compilation can fail if there is no main program or if a USEd module has not been compiled.
    intro: |
      gfortran m.f90

      gives an error

      undefined reference to `main'

      if m.f90 does not contain a main program.

      gfortran -c m.f90

      gives an error like

      Cannot open module file 'x.mod'

      if the file containing module x has not previously been compiled.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1517106458281844736
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">gfortran m.f90<br><br>gives an error<br><br>undefined reference to `main&#39;<br><br>if m.f90 does not contain a main program.<br><br>gfortran -c m.f90<br><br>gives an error like<br><br>Cannot open module file &#39;x.mod&#39;<br><br>if the file containing module x has not previously been compiled.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1517106458281844736?ref_src=twsrc%5Etfw">April 21, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 22-Apr-2022

  # TODO
  - title: Fortran Package Manger simplifies building programs.
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1517462836062081024
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/yy45zLGaFP">https://t.co/yy45zLGaFP</a><br>Fortran Package Manager (fpm) lets you build a program/library, run the executables/tests, and distribute it as a dependency to other projects. It detects module dependencies and compiles files in<br>the proper order, being more Fortran-aware than make.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1517462836062081024?ref_src=twsrc%5Etfw">April 22, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 23-Apr-2022

  # TODO
  - title: Fortran-lang has a section on Building Programs, and F18 has a compiler options comparison.
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1517857866757124099
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/8uXGmDfWXi">https://t.co/8uXGmDfWXi</a> discusses compiling and linking, make, meson, and Cmake, and the distribution of libraries and programs.<a href="https://t.co/dBCWh320p6">https://t.co/dBCWh320p6</a> lists equivalent options of many compilers.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1517857866757124099?ref_src=twsrc%5Etfw">April 23, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 25-Apr-2022

  # TODO
  - title: Compiler Explorer shows the assembly code generated by many Fortran compilers.
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1518552648647168001
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/yR6ucetSCi">https://t.co/yR6ucetSCi</a> Compiler Explorer lets you paste code in many languages, including Fortran, and see the assembly code generated by compilers including gfortran, ifort, ifx, LLVM-Flang, and IBM Power. Doing so can identify inefficiencies and compiler bugs.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1518552648647168001?ref_src=twsrc%5Etfw">April 25, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 26-Apr-2022

  # TODO
  - title: Compilers may accept extensions by default but have options to flag non-standard code.
    intro: |
      Compilers may accept extensions by default but have options to flag non-standard code, such as -std=[f2018, f2008, f2003, f95] for gfortran and -stand:[f18, f08, f03, f95, f90] for ifort. For ifort, -standard-semantics causes the program to behave as the standard requires.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1518923088599162880
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Compilers may accept extensions by default but have options to flag non-standard code, such as -std=[f2018, f2008, f2003, f95] for gfortran and -stand:[f18, f08, f03, f95, f90] for ifort. For ifort, -standard-semantics causes the program to behave as the standard requires.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1518923088599162880?ref_src=twsrc%5Etfw">April 26, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 28-Apr-2022

  # TODO
  - title: Use ifort -fast or gfortran -O3 -march=native for speed.
    intro: |
      Use the ifort -fast and gfortran -O3 -march=native options to increase speed. Gfortran -Ofast turns on -ffast-math and can give a further 2x speedup in some cases, but it can also give incorrect results and should be used with care. Use gfortran -Og to debug.
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1519634828265762816
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use the ifort -fast and gfortran -O3 -march=native options to increase speed. Gfortran -Ofast turns on -ffast-math and can give a further 2x speedup in some cases, but it can also give incorrect results and should be used with care. Use gfortran -Og to debug.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1519634828265762816?ref_src=twsrc%5Etfw">April 28, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 29-Apr-2022

  # TODO
  - title: When is the -ffast-math option safe?
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1519998641133563905
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/Jnai5VcixS">https://t.co/Jnai5VcixS</a><br>discusses when using the -ffast-math option is safe.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1519998641133563905?ref_src=twsrc%5Etfw">April 29, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Use IANY instead of nested IOR, IALL instead of nested IAND.
    intro: |
      Use IANY instead of nested IOR, IALL instead of nested IAND. Never use .OR. or .AND. on non-LOGICAL values! See also
    file: ~
    file0: iany.f90
    url: https://twitter.com/fortrantip/status/1520241782038007808
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use IANY instead of nested IOR, IALL instead of nested IAND. Never use .OR. or .AND. on non-LOGICAL values! See also <a href="https://t.co/Eusy3dn9eH">https://t.co/Eusy3dn9eH</a> <a href="https://t.co/A8Pnk1qlpp">pic.twitter.com/A8Pnk1qlpp</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1520241782038007808?ref_src=twsrc%5Etfw">April 30, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 01-May-2022

  # TODO
  - title: B, O, Z edit descriptors can be used to print integers as binary, octal, or hexadecimal.
    intro: |
      A BOZ constant with prefix B, O, or Z for binary, octal, or hexadecimal can be passed to the INT or REAL function to set an integer or real variable. The B, O, and Z edit descriptors can print integers as BOZ constants.
    file: ~
    file0: boz.f90
    url: https://twitter.com/fortrantip/status/1520746070829158400
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A BOZ constant with prefix B, O, or Z for binary, octal, or hexadecimal can be passed to the INT or REAL function to set an integer or real variable. The B, O, and Z edit descriptors can print integers as BOZ constants.<a href="https://t.co/SHnhM3h9BP">pic.twitter.com/SHnhM3h9BP</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1520746070829158400?ref_src=twsrc%5Etfw">May 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 02-May-2022

  # TODO
  - title: Use compiler options to catch the use of uninitialized variables.
    intro: |
      To catch the use of uninitialized variables, initialize real variables to signalling NaN and integers to -999 and trap NaNs at run time with

      gfortran -g -ffpe-trap=invalid,overflow -finit-real=snan -finit-integer=-999 -fbacktrace a.f90

      For ifort see
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1521100997195669504
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">To catch the use of uninitialized variables, initialize real variables to signalling NaN and integers to -999 and trap NaNs at run time with<br><br>gfortran -g -ffpe-trap=invalid,overflow -finit-real=snan -finit-integer=-999 -fbacktrace a.f90<br><br>For ifort see <a href="https://t.co/gjX3gj8seB">https://t.co/gjX3gj8seB</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1521100997195669504?ref_src=twsrc%5Etfw">May 2, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 03-May-2022

  # TODO
  - title: Fortran 2003 standardized the interoperation of Fortran and C.
    intro: |
      &nbsp;
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1521476255165698051
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr"><a href="https://t.co/QqGhsxGbj6">https://t.co/QqGhsxGbj6</a> <br>F2003 standardized interoperation with C. Fortran can call a C function with an INTERFACE, and C can call Fortran procedures with prototypes. A C function with a void result interoperates with a Fortran subroutine. ISO_C_BINDING defines compatible KINDs.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1521476255165698051?ref_src=twsrc%5Etfw">May 3, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 04-May-2022

  # TODO
  - title: C library functions can be called if an INTERFACE is provided.
    intro: |
      Fortran can call a function from the C standard library if an INTERFACE is provided. For example, it may be faster to call C atoi() or atof() than to use an internal read to read an integer or double from a string.
    file: ~
    file0: atoi_vs_read.f90
    url: https://twitter.com/fortrantip/status/1521921486302363656
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran can call a function from the C standard library if an INTERFACE is provided. For example, it may be faster to call C atoi() or atof() than to use an internal read to read an integer or double from a string. <a href="https://t.co/AbiHFnSvok">pic.twitter.com/AbiHFnSvok</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1521921486302363656?ref_src=twsrc%5Etfw">May 4, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 05-May-2022

  # TODO
  - title: Non-pointer arguments of C functions should have the VALUE attribute in the Fortran interface.
    intro: |
      Arguments corresponding to non-pointer arguments of C functions must have the VALUE attribute in the Fortran interface. A C const argument can be INTENT(IN) in the Fortran interface.
    file: ~
    file0: xsum_vec.f90
    url: https://twitter.com/fortrantip/status/1522208519096836096
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Arguments corresponding to non-pointer arguments of C functions must have the VALUE attribute in the Fortran interface. A C const argument can be INTENT(IN) in the Fortran interface. <a href="https://t.co/oHM1F6sbLK">pic.twitter.com/oHM1F6sbLK</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1522208519096836096?ref_src=twsrc%5Etfw">May 5, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 06-May-2022

  # TODO
  - title: A simple derived type with the BIND(C) attribute interoperates with a C struct.
    intro: |
      Use the bind(c) attribute to make a derived type compatible with C, with restrictions listed at
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1522553330282778625
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use the bind(c) attribute to make a derived type compatible with C, with restrictions listed at <a href="https://t.co/P7PbDVsc9a">https://t.co/P7PbDVsc9a</a>. For example,<br>   <br>type, bind(c) :: date<br>   integer (kind=c_int) :: year, month<br>end type<br><br>interoperates with<br><br>typedef struct {<br>   int year, month;<br>} date;</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1522553330282778625?ref_src=twsrc%5Etfw">May 6, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 07-May-2022

  # TODO
  - title: The Fortran name can differ from the C name of a function if the NAME attribute appears in BIND.
    intro: |
      The Fortran name can differ from the C name of a function if the NAME attribute appears in BIND. A variadic C function such as printf can be given multiple Fortran interfaces with different names and sets of argument types.
    file: ~
    file0: printf.f90
    url: https://twitter.com/fortrantip/status/1522907590048587776
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The Fortran name can differ from the C name of a function if the NAME attribute appears in BIND. A variadic C function such as printf can be given multiple Fortran interfaces with different names and sets of argument types.<a href="https://t.co/EhQGNNOHaj">pic.twitter.com/EhQGNNOHaj</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1522907590048587776?ref_src=twsrc%5Etfw">May 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 08-May-2022

  # TODO
  - title: C++ functions can be called from Fortran if they are declared extern "C" and have C-like arguments.
    intro: |
      C++ functions can be called from Fortran if they are declared extern "C" and have C-like arguments, so the random number generators for uniform and non-uniform distributions in the C++ standard library are accessible through simple wrappers.
    file: ~
    file0: xnormal.f90
    url: https://twitter.com/fortrantip/status/1523289035900276736
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">C++ functions can be called from Fortran if they are declared extern &quot;C&quot; and have C-like arguments, so the random number generators for uniform and non-uniform distributions in the C++ standard library are accessible through simple wrappers.<a href="https://t.co/5we4VwUqtJ">pic.twitter.com/5we4VwUqtJ</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1523289035900276736?ref_src=twsrc%5Etfw">May 8, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 12-May-2022

  # TODO
  - title: Use the std::span container from C++ 20 to view a contiguous Fortran array with a STL-compatible interface.
    intro: |
      Use the std::span container from C++ 20 to create a view of a contiguous Fortran array with a STL-compatible interface. std::sort will sort the array in-place. Also works for other STL algorithms.
      From @IvanPribec. #cpp
    file: ~
    file0: test_sort.f90
    url: https://twitter.com/fortrantip/status/1524730212176564230
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use the std::span container from C++ 20 to create a view of a contiguous Fortran array with a STL-compatible interface. std::sort will sort the array in-place. Also works for other STL algorithms.<br>From <a href="https://twitter.com/IvanPribec?ref_src=twsrc%5Etfw">@IvanPribec</a>. <a href="https://twitter.com/hashtag/cpp?src=hash&amp;ref_src=twsrc%5Etfw">#cpp</a><a href="https://t.co/WVazkhQ5Et">pic.twitter.com/WVazkhQ5Et</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1524730212176564230?ref_src=twsrc%5Etfw">May 12, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 14-May-2022

  # TODO
  - title: Fortran array x(n1,n2) passed to C array x[n2][n1]
    intro: |
      A Fortran array 

      real x(n1,n2) 

      matches a C array

      float x[n2][n1]

      Matrices can be passed to C99 variable length arrays. A procedure with explicit-shape arrays calling C can be wrapped in a procedure with assumed-shape array arguments for ease of use.
    file: ~
    file0: xcol_sum.f90
    url: https://twitter.com/fortrantip/status/1525473581492314112
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A Fortran array <br><br>real x(n1,n2) <br><br>matches a C array<br><br>float x[n2][n1]<br><br>Matrices can be passed to C99 variable length arrays. A procedure with explicit-shape arrays calling C can be wrapped in a procedure with assumed-shape array arguments for ease of use.<a href="https://t.co/5966N4LY0t">pic.twitter.com/5966N4LY0t</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1525473581492314112?ref_src=twsrc%5Etfw">May 14, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 15-May-2022

  # TODO
  - title: Common block and module variables with bind(c) can be accessed from C.
    intro: |
      An interoperable common block or module variable with the bind(c) attribute can be accessed from C. A constant should be PROTECTED in Fortran and extern const in C. A PARAMETER is not interoperable.
    file: ~
    file0: xcircle.f90
    url: https://twitter.com/fortrantip/status/1525817060856561667
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An interoperable common block or module variable with the bind(c) attribute can be accessed from C. A constant should be PROTECTED in Fortran and extern const in C. A PARAMETER is not interoperable.<a href="https://t.co/oEVUQROAog">pic.twitter.com/oEVUQROAog</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1525817060856561667?ref_src=twsrc%5Etfw">May 15, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 16-May-2022

  # TODO
  - title: An allocated allocatable array can be passed to C as an explicit-shape array.
    intro: |
      An ALLOCATABLE array does not have a C counterpart, but it can be ALLOCATED and passed to C as an explicit-shape array. This can be done for the allocated components of a derived type which is not itself interoperable.
    file: ~
    file0: xscale.f90
    url: https://twitter.com/fortrantip/status/1526179041652486147
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An ALLOCATABLE array does not have a C counterpart, but it can be ALLOCATED and passed to C as an explicit-shape array. This can be done for the allocated components of a derived type which is not itself interoperable.<a href="https://t.co/xAnFxnFM5y">pic.twitter.com/xAnFxnFM5y</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1526179041652486147?ref_src=twsrc%5Etfw">May 16, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 17-May-2022

  # TODO
  - title: Use TYPE(C_PTR) and C_F_POINTER to call a C function returning a pointer.
    intro: |
      In ISO_C_BINDING, TYPE(C_PTR) holds a C pointer, and C_F_POINTER(CPTR,FPTR[, SHAPE]) associates the target of a C pointer to a Fortran pointer. Use them to call a C function that returns a pointer, possibly to an unknown amount of data.
    file: ~
    file0: c_f_pointer.f90
    url: https://twitter.com/fortrantip/status/1526575755903246336
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In ISO_C_BINDING, TYPE(C_PTR) holds a C pointer, and C_F_POINTER(CPTR,FPTR[, SHAPE]) associates the target of a C pointer to a Fortran pointer. Use them to call a C function that returns a pointer, possibly to an unknown amount of data.<a href="https://t.co/5YsyOOakbR">pic.twitter.com/5YsyOOakbR</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1526575755903246336?ref_src=twsrc%5Etfw">May 17, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-May-2022

  # TODO
  - title: Use valgrind to find memory leaks in programs that use pointers.
    intro: |
      Use tools such as valgrind to find memory leaks in programs that use pointers.
    file: ~
    file0: leak.f90
    url: https://twitter.com/fortrantip/status/1526882686467448833
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Use tools such as valgrind to find memory leaks in programs that use pointers. <a href="https://t.co/JIFQkF0Yti">pic.twitter.com/JIFQkF0Yti</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1526882686467448833?ref_src=twsrc%5Etfw">May 18, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-May-2022

  # TODO
  - title: Use c_funloc() to pass a Fortran function as an argument to a C function.
    intro: |
      A Fortran function can be passed as an argument to a C function. C_funloc(x) of iso_c_binding has a result of type(c_funptr) with the C address of function x or a pointer to a function.
    file: ~
    file0: c_func_ptr.f90
    url: https://twitter.com/fortrantip/status/1527249982692245510
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A Fortran function can be passed as an argument to a C function. C_funloc(x) of iso_c_binding has a result of type(c_funptr) with the C address of function x or a pointer to a function.<a href="https://t.co/xaBmcFDoPK">pic.twitter.com/xaBmcFDoPK</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1527249982692245510?ref_src=twsrc%5Etfw">May 19, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-May-2022

  # TODO
  - title: An omitted Fortran optional argument corresponds to a NULL argument of a C function.
    intro: |
      An omitted Fortran optional argument corresponds to a NULL argument of a C function.
    file: ~
    file0: xstrtof.f90
    url: https://twitter.com/fortrantip/status/1527632181983645696
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An omitted Fortran optional argument corresponds to a NULL argument of a C function.<a href="https://t.co/WGIL9ZOuoW">pic.twitter.com/WGIL9ZOuoW</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1527632181983645696?ref_src=twsrc%5Etfw">May 20, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 21-May-2022

  # TODO
  - title: C can call Fortran procedures with prototypes generated by gfortran -fc-prototypes.
    intro: |
      C can call interoperable Fortran bind(c) procedures with prototypes, which can be generated with

      gfortran -c -fc-prototypes source.f90

      Linking the C and Fortran object files with the Fortran compiler enables access to the Fortran run-time library.
    file: ~
    file0: print_stats.f90
    url: https://twitter.com/fortrantip/status/1527982071943159809
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">C can call interoperable Fortran bind(c) procedures with prototypes, which can be generated with<br><br>gfortran -c -fc-prototypes source.f90<br><br>Linking the C and Fortran object files with the Fortran compiler enables access to the Fortran run-time library.<a href="https://t.co/nzl0FXzeUf">pic.twitter.com/nzl0FXzeUf</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1527982071943159809?ref_src=twsrc%5Etfw">May 21, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 22-May-2022

  # TODO
  - title: List of books with Fortran code other than Fortran textbooks.
    intro: |
      Many books other than Fortran textbooks have included Fortran code, listed at
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1528326631043088384
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Many books other than Fortran textbooks have included Fortran code, listed at <a href="https://t.co/3TNLI1ekxM">https://t.co/3TNLI1ekxM</a>.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1528326631043088384?ref_src=twsrc%5Etfw">May 22, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 25-May-2022

  # TODO
  - title: Ways of declaring character variables
    intro: |
      The code

      character(5) :: a, b, c*3

      declares two character variables of length 5 and one of length 3, but clearer is

      character(5) :: a, b
      character(3) :: c

      or 

      character(len=5) :: a, b
      character(len=3) :: c

      or 

      character :: a*5, b*5, c*3
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1529412759351336960
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The code<br><br>character(5) :: a, b, c*3<br><br>declares two character variables of length 5 and one of length 3, but clearer is<br><br>character(5) :: a, b<br>character(3) :: c<br><br>or <br><br>character(len=5) :: a, b<br>character(len=3) :: c<br><br>or <br><br>character :: a*5, b*5, c*3</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1529412759351336960?ref_src=twsrc%5Etfw">May 25, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 26-May-2022

  # TODO
  - title: Special meanings of * and / in list-directed input
    intro: |
      In list-directed input using the * format, n* means skip n items, n*i means set n items to i, i,,j means set items 1 and 3 to i and j and keep item 2 unchanged, and / means to stop reading. The n*i syntax also applies to DATA statements. Thx to urbanjost.
    file: ~
    file0: list_directed_read.f90
    url: https://twitter.com/fortrantip/status/1529807207080009729
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In list-directed input using the * format, n* means skip n items, n*i means set n items to i, i,,j means set items 1 and 3 to i and j and keep item 2 unchanged, and / means to stop reading. The n*i syntax also applies to DATA statements. Thx to urbanjost.<a href="https://t.co/qBAZnKLAEA">pic.twitter.com/qBAZnKLAEA</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1529807207080009729?ref_src=twsrc%5Etfw">May 26, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 31-May-2022

  # TODO
  - title: Wrap a procedure with explicit shape array arguments in a procedure with an assumed shape arguments for safety.
    intro: |
      A procedure with explicit shape array arguments can be wrapped by a procedure with assumed shape arguments that is safer to use, since the correct array dimensions can be obtained from SIZE or SHAPE and be passed.
    file: ~
    file0: wrap_explicit_shape.f90
    url: https://twitter.com/fortrantip/status/1531620667220709377
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">A procedure with explicit shape array arguments can be wrapped by a procedure with assumed shape arguments that is safer to use, since the correct array dimensions can be obtained from SIZE or SHAPE and be passed.<a href="https://t.co/SbZ5kImuFq">pic.twitter.com/SbZ5kImuFq</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1531620667220709377?ref_src=twsrc%5Etfw">May 31, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO
  - title: Sequence association effectively lets you pass a pointer to an array element.
    intro: |
      With sequence association for explicit-shape and assumed-size arrays, you can pass a single array element to an array dummy argument to pass a pointer to a location in the array, as shown in the previous code. Restrictions are discussed at
    file: ~
    file0: ~
    url: https://twitter.com/fortrantip/status/1531621102879133696
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">With sequence association for explicit-shape and assumed-size arrays, you can pass a single array element to an array dummy argument to pass a pointer to a location in the array, as shown in the previous code. Restrictions are discussed at <a href="https://t.co/2EMAeNtUJB">https://t.co/2EMAeNtUJB</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1531621102879133696?ref_src=twsrc%5Etfw">May 31, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 01-Jun-2022

  # TODO
  - title: With sequence association, the shapes of the actual and dummy arguments need not match.
    intro: |
      With sequence association the actual argument and an explicit-shape or assumed-size dummy argument can have different shapes or ranks, so a 6-element 1-D array can be passed to a procedure as a 2x3 or 3x2 2-D array.
    file: ~
    file0: print_mat.f90
    url: https://twitter.com/fortrantip/status/1532039979723022337
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">With sequence association the actual argument and an explicit-shape or assumed-size dummy argument can have different shapes or ranks, so a 6-element 1-D array can be passed to a procedure as a 2x3 or 3x2 2-D array. <a href="https://t.co/4gxb6jWR6s">pic.twitter.com/4gxb6jWR6s</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1532039979723022337?ref_src=twsrc%5Etfw">June 1, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 07-Jun-2022

  # TODO
  - title: Use the optional KIND argument of SIZE, MINLOC, FINDLOC etc. for large arrays.
    intro: |
      Since the maximum 32-bit integer is about 2e9, use the optional KIND argument of SIZE, MINLOC, FINDLOC etc. to query an array that may be larger than this or compile with an option such as gfortran
      -fdefault-integer-8 to make the default integer 64-bit.
    file: ~
    file0: size_test.f90
    url: https://twitter.com/fortrantip/status/1534178812501577731
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Since the maximum 32-bit integer is about 2e9, use the optional KIND argument of SIZE, MINLOC, FINDLOC etc. to query an array that may be larger than this or compile with an option such as gfortran<br>-fdefault-integer-8 to make the default integer 64-bit.<a href="https://t.co/2E4edmUTp0">pic.twitter.com/2E4edmUTp0</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1534178812501577731?ref_src=twsrc%5Etfw">June 7, 2022</a></blockquote><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'
