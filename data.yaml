# This data is used to generate the tip pages

tips:

  # 17-Dec-2021

  - title: Hello World
    intro: |
      [Hello World](https://en.wikipedia.org/wiki/%22Hello,_World!%22_program) in Fortran is
    file: hello-world.f90
    concl: |
      (Every Fortran program must have an `end` statement.)
    url: https://twitter.com/fortrantip/status/1471887565745799173
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Hello World in Fortran is<br><br>print*,&quot;Hello, World.&quot;<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471887565745799173?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Intrinsic data types
    intro: |
      Fortran has 5 intrinsic data types: integer, real, complex, logical, and character.
      The types have various `kind`s that determine the range of data they can represent.
    file: ~
    url: https://twitter.com/fortrantip/status/1471890355561943054
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran has 5 intrinsic data types: integer, real, complex, logical, and character. The types have various KINDs that determine the range of data they can represent.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471890355561943054?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`do` loop'
    intro: |
      The primary looping construct in Fortran is `do` ... `end do`.
      A program to print the sum the squares of the integers from 1 to 5 is
    file: do-enddo.f90
    url: https://twitter.com/fortrantip/status/1471891644370796550
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The primary looping construct in Fortran is do ... end do. A program to print the sum the squares of the integers from 1 to 5 is<br><br>implicit none<br>integer :: i,ssq<br>ssq = 0<br>do i=1,5<br> ssq = ssq + i**2<br>end do<br>print*,&quot;sum of squares is &quot;,ssq<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471891644370796550?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`exit`ing a `do` loop'
    intro: |
      You `exit` a loop as shown in the code below,
      which accumulates the sums of squared integers until the sum exceeds 100.
    file: do-exit.f90
    url: https://twitter.com/fortrantip/status/1471895490346291206
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">You EXIT a loop as shown in the code below, which accumulates the sums of squared integers until the sum exceeds 100<br><br>implicit none<br>integer :: i,ssq<br>ssq = 0<br>i = 0<br>do<br> i = i+1<br> ssq = ssq + i**2<br> if (ssq &gt; 100) exit<br>end do <br>print*,&quot;sum of squares from 1 to &quot;,i,&quot; is&quot;,ssq<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471895490346291206?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Fortran compilers and tutorials
    intro: |
      Two good sites to get started with Fortran are
      <https://fortran-lang.org> and <https://fortranwiki.org/fortran/show/HomePage>.
      A good free compiler is `gfortran`, part of GCC.
      Intel Fortran is also free.
      LFortran is an interactive compiler that covers most but not yet all of Fortran.
    file: ~
    url: https://twitter.com/fortrantip/status/1471897319671046147
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Two good sites to get started with Fortran are <a href="https://t.co/i6lkcIfPqy">https://t.co/i6lkcIfPqy</a> and <a href="https://t.co/uxmVspKsPm">https://t.co/uxmVspKsPm</a> . A good free compiler is gfortran, part of gcc. Intel Fortran is also free. LFortran is an interactive compiler that covers most but not yet all of Fortran.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471897319671046147?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`**` is the exponentiation operator'
    intro: |
      The exponentiation operator in Fortran is `**`, as in Python.
    file: expon.f90
    concl: |
      Many Fortran operators and intrinsic functions are elemental, and brackets denote arrays.
    url: https://twitter.com/fortrantip/status/1471903802185986050
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The exponentiation operator in Fortran is **, as in Python. <br><br>print*,1.2**2<br><br>gives 1.44<br><br>Many Fortran operators and intrinsic functions are elemental, and brackets denote arrays, so<br><br>print*,[1.0,1.1,1.2,1.3]**2<br><br>gives<br><br>1.00000000 1.21000004 1.44000006 1.68999982</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471903802185986050?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Integer division truncates
    intro: ~
    file: int-trunc.f90
    concl: |
      2/3 = 0 in Fortran because the quotient of two integers is truncated to an integer.
      The quotient of an integer and a real is a real.
    url: https://twitter.com/fortrantip/status/1471936756857643008
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">print*,2+3,2-3,2*3,2/3,2/3.0,2.0/3,2**3<br><br>gives<br><br>5 -1 6 0 0.6666667 0.6666667 8<br><br>2/3 = 0 in Fortran because the quotient of two integers is truncated to an integer. The quotient of an integer and a real is a real.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471936756857643008?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Array intrinsic functions: `sum`, `minval`, `maxval`, `minloc`, `findloc`'
    intro: |
      Fortran has many array intrinsic functions. Below, `!` starts a comment.
    file: array-intrinsics.f90
    url: https://twitter.com/fortrantip/status/1471989760046641153
    embed: '<blockquote class="twitter-tweet"><p lang="fr" dir="ltr">Fortran has many array intrinsic functions. Below, ! starts a comment.<br><br>integer, parameter :: vec(3) = [4,1,9]<br>print*,minval(vec),maxval(vec) ! output: 1 9<br>print*,sum(vec),product(vec) ! 14 36<br>print*,minloc(vec),maxloc(vec) ! 2 3<br>print*,findloc(vec,9),findloc(vec,8) ! 3 0<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471989760046641153?ref_src=twsrc%5Etfw">December 17, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Fortran array sections contain both endpoints
    intro: |
      Fortran array sections contain both endpoints like Julia, Matlab and R, unlike Python.
    file: array-sections.f90
    url: https://twitter.com/fortrantip/status/1471994100161388545
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran array sections contain both endpoints like Julia, Matlab and R, unlike Python.<br><br>integer, parameter :: v(3) = [10,20,30]<br>print*,v(1:2) ! output 10 20<br>print*,v(:2) ! 10 20<br>print*,v(2:3) ! 20 30<br>print*,v(2:) ! 20 30<br>print*,v(::2) ! 10 30 -- stride of 2</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471994100161388545?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Fortran arrays can have any lower bound (the default is 1)
    intro: |
      Fortran arrays can have any lower bound. 
      The default is 1.
      Array functions have optional mask arguments to determine the elements used.    
    file: array-lbound.f90
    url: https://twitter.com/fortrantip/status/1471997763848183810
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran arrays can have any lower bound. <br>The default is 1. Array functions have optional mask arguments to determine the elements used.<br><br>integer :: v(-1:1) = [1,-2,3]<br>print*,lbound(v),ubound(v),size(v) ! -1 1 3<br>print*,sum(v) ! 2<br>print*,sum(v,mask=v&gt;0) ! 4 -- sum excludes -2<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1471997763848183810?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`sum` and other array functions have an optional `dim`ension argument'
    intro: ~
    file: sum-dim.f90
    url: https://twitter.com/fortrantip/status/1472018791525720069
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">sum and other array functions have an optional dim(ension) argument<br><br>integer :: v(2,3) ! 2x3 matrix<br>v(1,:) = [1,2,3]<br>v(2,:) = 10*v(1,:) ! set to [10,20,30]<br>print*,sum(v) ! all elements: 66<br>print*,sum(v,dim=1) ! sum each row: 6 60<br>print*,sum(v,dim=2) ! sum each col: 11 22 33</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472018791525720069?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 18-Dec-2021

  - title: Fortran has allocation-on-assignment
    intro: |
      Fortran has allocation on assignment,
      but you cannot use the `allocate` statement for an array that is already allocated.
    file: alloc-on-assign.f90
    url: https://twitter.com/fortrantip/status/1472181598833549316
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran has allocation on assignment, but you cannot use the ALLOCATE statement for an array that is allocated<br><br>integer, allocatable :: v(:)<br>v = [4,9]<br>deallocate(v) ! necessary for line below to work<br>allocate (v,source=[4,9]) ! same as above</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472181598833549316?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'
    
  - title: 'New Fortran code should use free source form and `.f90` suffix'
    intro: |
      New Fortran code should be written using free source form and stored in a file with a `.f90` file extension.
      Free form was introduced in the Fortran 90 standard,
      but using the `.f90` suffix does NOT mean the code is restricted to Fortran 90 features.
      Don't use the `.f95`, `.f08`, `.f18` suffixes, which are not recognized by many tools.
    file: ~
    url: https://twitter.com/fortrantip/status/1472183935044145157
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">New Fortran code should be written using free source form and stored in a file with the .f90 suffix. Free form was introduced in the Fortran 90 standard, but using the .f90 suffix does NOT mean the code is restricted to Fortran 90 features. Don&#39;t use .f95 .f08 .f18 suffixes.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472183935044145157?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`if`-`else if`-`end if` block'
    intro: ~
    file: if-block.f90
    url: https://twitter.com/fortrantip/status/1472202678054920196
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">If-elseif-endif block:<br><br>integer :: i<br>do i=-1,1<br> print*,i<br> if (i &lt; 0) then<br> print*,&quot;negative&quot;<br> else if (i == 0) then<br> print*,&quot;zero&quot;<br> else<br> print*,&quot;positive&quot;<br> end if<br>end do<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472202678054920196?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`merge(x, y, cond)`'
    intro: |
      `merge(x, y, cond)` returns `x` if the condition `cond` is true, otherwise `y`.
      We can get the same result as the previous tip:
    file: merge.f90
    concl: |
      Similar to the three-argument usage of
      [`numpy.where`](https://numpy.org/doc/stable/reference/generated/numpy.where.html).
    url: https://twitter.com/fortrantip/status/1472205323763073026
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">merge(x,y,condition) returns x if condition is true, otherwise y. Same output as previous:<br><br>integer :: i<br>do i=-1,1<br> print*,i<br> ! &quot;zero&quot; padded to have same length as &quot;negative&quot;<br> print*,merge(&quot;negative&quot;,merge(&quot;zero &quot;, &amp; <br> &quot;positive&quot;,i==0),i&lt;0)<br>end do<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472205323763073026?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'An array of character variables has elements of the same `len`gth'
    intro: ~
    file: char-array.f90
    url: https://twitter.com/fortrantip/status/1472207576133783564
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">An array of character variables has elements of the same LEN(gth).<br><br>character(len=5) :: w(3)<br>w = [&quot;one&quot;,&quot;four&quot;,&quot;seven&quot;] ! invalid<br>w = [&quot;one &quot;,&quot;four &quot;,&quot;seven&quot;] ! same as below<br>w = [character(5) :: &quot;one&quot;,&quot;four&quot;,&quot;seven&quot;] <br>print*,w<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472207576133783564?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Character variables are padded with spaces at the end if necessary
    intro: |
      Fortran character variables are padded with spaces at the end if necessary.
      The `//` operator concatenates.
      `trim` removes trailing spaces.[^1]

      [^1]: Use `trim(adjustl(s))` to remove both leading and trailing spaces.
    file: char-pad.f90
    url: https://twitter.com/fortrantip/status/1472209602074849285
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran character variables are padded with spaces at the end if necessary. The // operator concatenates. Trim removes trailing spaces.<br><br>character (len=5) :: v = &quot;one&quot;<br>print*,&quot;&#39;&quot; // v // &quot;&#39;&quot; ! &#39;one &#39;<br>print*,&quot;&#39;&quot; // trim(v) // &quot;&#39;&quot; ! &#39;one&#39;<br>print*,len(v),len_trim(v) ! 5 3<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472209602074849285?ref_src=twsrc%5Etfw">December 18, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Fortran has a one-line `if`'
    intro: |
      In addition to `if`-`else if`, Fortran has a one-line `if`:

      ```text
      if (condition) executable_statement
      ```
    file: if-one-line.f90
    url: https://twitter.com/fortrantip/status/1472365082067755017
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In addition to if-elseif, Fortran has a one-line if:<br>if (condition) executable_statement<br><br>integer :: i<br>do i=-1,1<br> if (i /= 0) print*,i,1/i ! one-line if equivalent to below<br> if (i /= 0) then<br> print*,i,1/i<br> end if<br>end do<br>end<br>! output:<br>! -1 -1<br>! -1 -1<br>! 1 1<br>! 1 1</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472365082067755017?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 19-Dec-2021 (first day that stored some source files in the Beliavsky/FortranTip repo)

  - title: '`associate` creates an alias for expressions or variables'
    intro: ~
    file: assoc.f90
    url: https://twitter.com/fortrantip/status/1472565511628197891
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Associate creates an alias for expressions or variables.<br><br>integer, allocatable :: u(:)<br>u = [4,9]<br>associate (v =&gt; u)<br>v = v - 2<br>print*,v ! 2 7<br>print*,u ! 2 7<br>associate (w =&gt; [4,9])<br>print*,w<br>w = w - 2 ! illegal since w set to a constant expression<br>end associate<br>end associate<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472565511628197891?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Loop variable after completion
    intro: |
      The loop variable equals the upper bound plus the stride
      after normal completion of a loop.
    file: loop-var.f90
    url: https://twitter.com/fortrantip/status/1472598697489965061
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">The loop variable equals the upper bound plus the stride<br>after normal completion of a loop<br><br>integer :: i<br>do i=1,3<br> if (i &gt; 1) exit<br>end do<br>print*,i ! 2<br>do i=1,3 ! stride of 1<br> continue ! placeholder<br>end do<br>print*,i ! 4<br>do i=1,3,2 ! stride of 2<br> continue<br>end do<br>print*,i ! 5<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472598697489965061?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>' 

  - title: '`pack` selects elements'
    intro: ~
    file: pack.f90
    url: https://twitter.com/fortrantip/status/1472600871192125451
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Pack selects elements<br><br>integer :: v(3) = [1,-4,9]<br>print*,pack(v,v&gt;0) ! 1 9 -- keep values &gt; 0<br>print*,count(v&gt;0) ! 2 -- count values &gt; 0<br>print*,size(v) ! 3<br>print*,sum(v) ! 6<br>print*,sum(v,v&gt;0) ! 10 -- sum has optional mask<br>print*,sum(pack(v,v&gt;0)) ! 10<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472600871192125451?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Functions should be `pure` and have `intent(in)` arguments
    intro: |
      `intent(in)` arguments cannot be changed.
      `pure` = no side effects.
      Use `subroutine` instead for a procedure with side effects.
    file: func.f90
    concl: |
      `real` in the function definition line indicates the type of the return value.
      By default, the value corresponding to a variable with the same name as the function
      is returned (here `area`).
    url: https://twitter.com/fortrantip/status/1472603894886932482
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Demo of a Fortran function. Intent(in) arguments<br>cannot be changed. Function arguments should be intent(in). Pure = no side-effects.<br><br>print*,area(3.,4.) ! 12<br>contains<br>real pure function area(length,width)<br>real, intent(in) :: length,width<br>area = length*width<br>end function area<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472603894886932482?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: '`elemental` functions broadcast arguments'
    intro: ~
    file: elemental.f90
    url: https://twitter.com/fortrantip/status/1472606914857078793
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Elemental functions broadcast arguments. Neat Fortran feature!<br><br>print*,area(3,4) ! 12<br>print*,area(3,[4,5]) ! 12 15<br>print*,area([3,4],[4,5]) ! 12 20<br>contains<br>integer elemental function area(length,width)<br>integer, intent(in) :: length,width<br>area = length*width<br>end function area<br>end</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472606914857078793?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Put functions and subroutines in modules to ensure that interfaces are checked
    intro: |
      Fortran procedures should be defined in modules to
      ensure that interfaces are checked.
    file: mod.f90
    url: https://twitter.com/fortrantip/status/1472610403884670976
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Fortran procedures should be defined in modules to<br>ensure that interfaces are checked.<br><br>module m<br>contains<br>integer function area(length,width)<br>integer, intent(in) :: length,width<br>area = length*width<br>end<br>end module m<br>program main<br>use m<br>print*,area(3,4) ! 12<br>end program main</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472610403884670976?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Avoid polluting the namespace by using `use`-`only`'
    intro: |
      In Fortran, 
      ```fortran
      use m
      ```
      is equivalent to Python
      ```python
      from m import *
      ```
      It is better to write
      ```fortran
      use m, only: foo, bar
      ```
      to avoid polluting the namespace and to clarify the origin of imported entities.
    file: ~
    url: https://twitter.com/fortrantip/status/1472613921886552065
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In Fortran, <br><br>use m<br><br>is equivalent to Python<br><br>from m import *<br><br>It is better to write <br><br>use m, only: foo, bar<br><br>to avoid polluting the namespace and to clarify the origin of imported entities.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472613921886552065?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # This is the first one with source code file in the FortranTip repo
  - title: Function overloading using an interface with module procedures
    intro: ~
    file: interface.f90
    file0: same
    url: https://twitter.com/fortrantip/status/1472629090758836229
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/qsfPFLVUkl">pic.twitter.com/qsfPFLVUkl</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472629090758836229?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO: maybe split into two?
  - title: Optional arguments (and the `random_number` intrinsic)
    intro: ~
    file: optional.f90
    file0: same
    url: https://twitter.com/fortrantip/status/1472684194765672450
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/ZNqwgg3Wgq">pic.twitter.com/ZNqwgg3Wgq</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472684194765672450?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Define and call a subroutine
    intro: ~
    file: subroutine.f90
    file0: subroutine.f90
    concl: |
      Subroutines are commonly used to return multiple values,
      although a function can return an array or a user-defined type that contains multiple values.
      Use functions when possible, but subroutines are often needed.
      The subroutine is invoked with the `call` statement.
    url: https://twitter.com/fortrantip/status/1472692305522044932
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/Wi7Imqi5vW">pic.twitter.com/Wi7Imqi5vW</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472692305522044932?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Subroutines can have `intent(in out)` arguments, but functions should not'
    intro: |
      A procedure argument can be `intent(in out)`,
      which means that it is an input that can be overwritten.
      Functions should not have such arguments, but subroutines often do.
      `intent(out)` means the argument is set to uninitialized upon entering the procedure.
    file: intent-in-out.f90
    file0: intent_in_out.f90
    url: https://twitter.com/fortrantip/status/1472696912541364224
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/3FjJkJUHSn">pic.twitter.com/3FjJkJUHSn</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472696912541364224?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Specify function and subroutine `intent`s'
    intro: |
      Function and subroutine argument `intent`s were introduced in the Fortran 90 standard.
      Much Fortran code does not specify intents, which is legal, but all new code should.
      Arguments should be `intent(in)` or `intent(out)` unless `intent(in out)` is necessary.
    file: ~
    url: https://twitter.com/fortrantip/status/1472698233298333699
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Function and subroutine argument INTENTs were introduced in the Fortran 90 standard. Much Fortran code does not specify intents, which is legal, but all new code should. Arguments should be intent(in) or intent(out) unless intent(in out) is necessary.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472698233298333699?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # TODO: update `file0` after fixing in FortranTip?
  - title: Procedures can be recursive
    intro: |
      Fortran procedures declared `recursive` can call themselves.
    file: recursive.f90
    file0: missing
    concl: |
      ````{warning}

      In GFortran v9 and v10 (and lower versions, presumably),
      this isn't allowed, and we get:
      ```text
      Error: ELEMENTAL attribute conflicts with RECURSIVE attribute
      ```
      ````
    url: https://twitter.com/fortrantip/status/1472702427740745728
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/czICWzekYU">pic.twitter.com/czICWzekYU</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472702427740745728?ref_src=twsrc%5Etfw">December 19, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: Use `parameter`s in modules to define constants
    intro: |
      A physical or mathematical constant such as $\pi$ that will be used 
      in many parts of a program should be defined as a `parameter` in a 
      module that is `use`d where needed.
      In the code below, `pi` is used both in module `m` and the main program.
    file: module-parameter.f90
    file0: module_parameter.f90
    concl: |
      One should declare a module `private` and list as `public`
      the entities that will be referenced outside the module.
      Module entities are public by default.
    url: https://twitter.com/fortrantip/status/1472718436040073226
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/vWJuAwle97">pic.twitter.com/vWJuAwle97</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472718436040073226?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  - title: 'Declare floating point variables with `kind`s'
    intro: |
      Although floating point variables can still be declared just `real`
      or `double precision` in Fortran, they should not be.
      Instead, the `kind` of `real` should be specified as a parameter
      that is used throughout the program.

      The code below can be changed from double to single or quadruple precision
      by simply changing the definition of `wp` (working precision) in `kind_mod`
      using the `kind` constants from the intrinsic `iso_fortran_env` module.

      Note the `_wp` suffix used in the literal constants for $\pi$ and $10.0$.
      Any literal constant without a suffix is considered single precision in Fortran,
      regardless of the number of digits provided.

      See <https://fortran-lang.org/learn/best_practices/floating_point> for more discussion.
    file: real-precision.f90
    file0: kind.f90
    url: https://twitter.com/fortrantip/status/1472771842242920451
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Created with <a href="https://twitter.com/carbon_app?ref_src=twsrc%5Etfw">@carbon_app</a> <a href="https://t.co/Pxu7PbR5b6">pic.twitter.com/Pxu7PbR5b6</a></p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472771842242920451?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # Note: this one is a comment on the previous tweet
  - title: 'Replace non-standard `REAL*8` declaration with `real(kind=real64)`'
    intro: |
      In older code, declarations such as[^1]
      ```fortran
      REAL*8 x
      ```
      are common but non-standard.
      They should be replaced by
      ```fortran
      real(kind=real64) :: x
      ```
      or 
      ```fortran
      real(kind=wp) :: x
      ```
      with `wp`[^wp] set appropriately (e.g., `use iso_fortran_env, only: wp => real64`).

      [^1]: Here indicating double precision (8-byte)
      [^wp]: "Working precision"
    file: ~
    url: https://twitter.com/fortrantip/status/1472772577600942083
    embed: '<blockquote class="twitter-tweet"><p lang="en" dir="ltr">In older code, declarations such as<br><br>real*8 x<br><br>are common but non-standard. They should be replaced by<br><br>real(kind=real64) :: x<br><br>or <br><br>real(kind=wp) :: x<br><br>with wp set appropriately.</p>&mdash; FortranTip (@fortrantip) <a href="https://twitter.com/fortrantip/status/1472772577600942083?ref_src=twsrc%5Etfw">December 20, 2021</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>'

  # 20-December-2021

  # ...

